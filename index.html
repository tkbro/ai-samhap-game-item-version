<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <title>3ë§¤ì¹­</title>
    <style>
        /* íŒŒí‹°í´ íš¨ê³¼ ìŠ¤íƒ€ì¼ */
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            z-index: 50;
        }
        
        @keyframes particle-float {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }
        
        :root {
            --cols: 5;
            --rows: 7;
            --gap: 1vw;
            --bg: #0b0f14;
            --fg: #e8f0ff;
            --muted: #7f8da3;
            --tile: #18202b;
            --blocked: #161922;
            --accent: #46d3ff;
            --ok: #67ff9a;
            --warn: #ffcc4d;
            --err: #ff6b6b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent
        }

        html, body {
            height: 100%
        }

        body {
            margin: 0;
            background: url('images/bg.png') no-repeat center center fixed;
            background-size: cover;
            color: var(--fg);
            font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        header {
            width: 100%;
            max-width: 480px;
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: linear-gradient(180deg,rgba(11,15,20,0.95),rgba(11,15,20,0.6) 70%,transparent);
            backdrop-filter: blur(6px);
        }

        #title {
            font-size: 23px;
            font-weight: 700;
            color: #fff;
            text-align: center
        }

        .stat {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center
        }

        .idtag {
            padding: 2px 6px;
            border: 1px solid #2a3443;
            border-radius: 8px;
            color: #cfe5ff;
            background: #121722
        }

        #version {
            font-size: 11px;
            color: #6f7f95
        }

        #boardWrap {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px
        }

        #board {
            width: 90vw;
            max-width: 480px;
            aspect-ratio: 5/7;
            display: grid;
            grid-template-columns: repeat(var(--cols),1fr);
            grid-template-rows: repeat(var(--rows),1fr);
            gap: var(--gap);
            position: relative;
            margin: 0 auto;
            overflow: visible;
            transition: box-shadow 0.2s ease;
        }
        
        /* ë˜ëŒë¦¬ê¸° íš¨ê³¼ */
        #board.undo-flash {
            box-shadow: 0 0 20px rgba(76, 175, 255, 0.7);
            animation: undo-pulse 0.3s ease-out;
        }
        
        @keyframes undo-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(0.98); }
            100% { transform: scale(1); }
        }

        .cell {
            aspect-ratio: 1/1;
            background: transparent;
            border: 1px solid #1c2736;
            border-radius: 14px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }

            .cell::after {
                content: "";
                position: absolute;
                inset: 0;
                border-radius: 14px;
                pointer-events: none;
                box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
            }

            .cell.blocked {
                background: var(--blocked);
                background-image: repeating-linear-gradient(135deg,#1f2533 0 8px,#141925 8px 16px);
                border-color: #20283a;
            }
            
            /* ì œê±° ê°€ëŠ¥í•œ ë¸”ë¡ ê°•ì¡° íš¨ê³¼ */
            .cell.removable-block {
                border: 2px solid #67ff9a;
                box-shadow: inset 0 0 12px rgba(103, 255, 154, 0.6);
                cursor: pointer;
                transition: all 0.2s ease-out;
            }
            
            .cell.removable-block:hover {
                border: 2px solid #67ff9a;
                box-shadow: inset 0 0 18px rgba(103, 255, 154, 0.8);
                transform: scale(1.05);
            }
            
            /* ì œê±° ë¶ˆê°€ëŠ¥í•œ ë¸”ë¡ íš¨ê³¼ */
            .cell.non-removable-block {
                border: 2px solid #555;
                box-shadow: inset 0 0 8px rgba(85, 85, 85, 0.4);
                cursor: not-allowed;
                opacity: 0.6;
                transition: all 0.2s ease-out;
            }
            
            .cell.non-removable-block:hover {
                border: 2px solid #666;
                box-shadow: inset 0 0 10px rgba(102, 102, 102, 0.5);
            }
        
            .cell.possible-move {
                background-color: rgba(70, 211, 255, 0.2);
                box-shadow: inset 0 0 12px rgba(70, 211, 255, 0.8);
                border-radius: 14px;
            }

            .cell.path-highlight {
                background-color: rgba(255, 204, 77, 0.3);
                box-shadow: inset 0 0 8px rgba(255, 204, 77, 0.6);
            }

        .tile {
            position: absolute;
            inset: 0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            user-select: none;
            -webkit-user-select: none;
            transition: transform .15s ease;
        }

            .tile.sel {
                border: 3px solid var(--accent);
                transform: scale(1.1);
                box-shadow: 0 0 15px var(--accent),0 0 25px rgba(70,211,255,0.7);
                z-index: 10;
            }

            .tile.spawn {
                animation: pop .22s ease-out;
            }

            .tile.bump {
                animation: bump .18s ease-out;
            }

            .tile.merge {
                animation: merge .5s ease-in-out;
            }
            
            .tile.merge-large {
                animation: merge-large .7s ease-in-out;
                z-index: 10;
            }
            
            .tile.merge-mega {
                animation: merge-mega .9s ease-in-out;
                z-index: 20;
            }
            
            /* ë³‘í•© í›„ ì¶”ê°€ íš¨ê³¼ - ë°˜ì§ì´ëŠ” í…Œë‘ë¦¬ íš¨ê³¼ */
            .tile.after-merge {
                animation: after-merge-glow 0.8s ease-in-out;
                z-index: 5;
            }
            
            .tile.after-merge-large {
                animation: after-merge-glow-large 1s ease-in-out;
                z-index: 10;
            }
            
            .tile.after-merge-mega {
                animation: after-merge-glow-mega 1.5s ease-in-out;
                z-index: 20;
            }
            
            .tile.wildcard {
                box-shadow: 0 0 15px gold, 0 0 25px rgba(255, 215, 0, 0.7);
                animation: wildcard-glow 1.5s infinite alternate;
            }
            
            /* ì•„ì´í…œì´ ìˆëŠ” íƒ€ì¼ ìŠ¤íƒ€ì¼ */
            .tile[data-has-item="true"] {
                border: 2px solid #ffc107;
                box-shadow: 0 0 10px rgba(255, 193, 7, 0.7);
            }
            
            .tile[data-has-item="true"]::after {
                content: "";
                position: absolute;
                top: 8px;
                right: 8px;
                width: 12px;
                height: 12px;
                background-color: #ffc107;
                border: 2px solid #fff;
                border-radius: 50%;
                box-shadow: 0 0 5px #ffc107;
                animation: item-glow 1.5s infinite alternate;
                z-index: 10;
            }
            
            @keyframes item-glow {
                from {
                    box-shadow: 0 0 3px gold;
                    transform: scale(1);
                }
                to {
                    box-shadow: 0 0 8px gold;
                    transform: scale(1.2);
                }
            }
            
            @keyframes wildcard-glow {
                from {
                    box-shadow: 0 0 10px gold, 0 0 20px rgba(255, 215, 0, 0.7);
                }
                to {
                    box-shadow: 0 0 15px gold, 0 0 30px rgba(255, 215, 0, 0.9);
                }
            }

        @keyframes pop {
            from {
                transform: scale(0.6);
                opacity: 0
            }

            to {
                transform: scale(1);
                opacity: 1
            }
        }

        @keyframes bump {
            0% {
                transform: scale(1)
            }

            50% {
                transform: scale(1.08)
            }

            100% {
                transform: scale(1)
            }
        }

        @keyframes merge {
            0% {
                transform: scale(0.95)
            }

            50% {
                transform: scale(1.12)
            }
            
            70% {
                transform: scale(1.05)
            }

            85% {
                transform: scale(1.02)
            }

            100% {
                transform: scale(1)
            }
        }
        
        @keyframes merge-large {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            }

            40% {
                transform: scale(1.15);
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 215, 0, 0.6);
            }
            
            60% {
                transform: scale(1.08) rotate(3deg);
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 0 0 25px rgba(255, 215, 0, 0.5);
            }
            
            80% {
                transform: scale(1.04) rotate(-1deg);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 215, 0, 0.4);
            }

            100% {
                transform: scale(1) rotate(0);
                box-shadow: 0 0 0 rgba(255, 255, 255, 0);
            }
        }
        
        @keyframes merge-mega {
            0% {
                transform: scale(0.95) rotate(-2deg);
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            }
            20% {
                transform: scale(1.2) rotate(5deg);
                box-shadow: 0 0 25px rgba(255, 255, 255, 0.9), 0 0 35px rgba(255, 215, 0, 0.8);
                filter: brightness(1.2);
            }
            40% {
                transform: scale(1.15) rotate(-4deg);
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 215, 0, 0.7);
                filter: brightness(1.1);
            }
            60% {
                transform: scale(1.1) rotate(3deg);
                box-shadow: 0 0 15px rgba(255, 255, 255, 0.7), 0 0 25px rgba(255, 215, 0, 0.6);
                filter: brightness(1.05);
            }
            80% {
                transform: scale(1.05) rotate(-1deg);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 215, 0, 0.4);
                filter: brightness(1.02);
            }
            100% {
                transform: scale(1) rotate(0);
                box-shadow: 0 0 0 rgba(255, 255, 255, 0);
                filter: brightness(1);
            }
        }

        .tile.moving {
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(70, 211, 255, 0.6);
            transform: scale(1.1);
            border: 2px solid var(--accent);
            border-radius: 12px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        #controlBar {
            width: 100%;
            max-width: 480px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 10px 0 16px;
        }

        .btn {
            appearance: none;
            border: 1px solid #2a3443;
            background: #121722;
            color: var(--fg);
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: transform .05s ease-out,background .2s, box-shadow 0.2s;
        }

            .btn:active {
                transform: scale(0.98)
            }
            
            /* ëª¬ìŠ¤í„° ì†Œí™˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
            #btnSpawnMonster {
                background: #1c2e3e;
                border-color: #3a7ea9;
                color: #a9d4ff;
            }
            
            #btnSpawnMonster:hover {
                background: #24394d;
                box-shadow: 0 0 8px rgba(58, 126, 169, 0.5);
            }
            
            /* ì¡°ì»¤ ì†Œí™˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
            #btnSpawnWildcard {
                background: #3d2c13;
                border-color: #bd9331;
                color: #ffd57f;
            }
            
            #btnSpawnWildcard:hover {
                background: #4d3919;
                box-shadow: 0 0 8px rgba(255, 215, 0, 0.5);
            }

        .msg {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%,-50%);
            background: rgba(17,26,40,0.7);
            border: 2px solid #223043;
            padding: 16px 24px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: bold;
            color: #ffcc4d;
            opacity: 0;
            min-width: 420px; /* ì¢Œìš° ì‚¬ì´ì¦ˆ ëŠ˜ë¦¼ */
            max-width: 90vw; /* í™”ë©´ì´ ì¢ì„ ë•Œë„ ê½‰ ì°¨ì§€ ì•Šê²Œ ì œí•œ */
            white-space: pre-line;
            transition: opacity .5s ease;
            z-index: 1000;
            pointer-events: none;
            line-height: 3;
            text-align: center;   /* í…ìŠ¤íŠ¸ ê°€ìš´ë° ì •ë ¬ */
        }
        
        /* ì ìˆ˜ í‘œì‹œ íŒì—… */
        .score-popup {
            position: absolute;
            font-weight: bold;
            font-size: 16px;
            color: white;
            text-shadow: 0 0 6px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.6);
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transform: translateY(0);
        }
        
        .score-popup.show {
            animation: score-float 1.8s ease-out forwards;
        }
        
        .score-popup.bonus {
            color: #ffcc4d;
            font-size: 20px;
            text-shadow: 0 0 8px rgba(70,211,255,0.8), 0 0 12px rgba(0,0,0,0.7);
        }
        
        .score-popup.mega-bonus {
            color: #67ff9a;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(103,255,154,0.8), 0 0 14px rgba(0,0,0,0.8);
        }
        
        @keyframes screen-flash {
            0% {
                opacity: 0;
            }
            15% {
                opacity: 0.4;
            }
            100% {
                opacity: 0;
            }
        }
        
        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            pointer-events: none;
            opacity: 0;
            z-index: 100;
            animation: screen-flash 0.3s ease-out;
        }
        
        @keyframes score-float {
            0% {
                opacity: 0;
                transform: translateY(0);
            }
            20% {
                opacity: 1;
            }
            80% {
                opacity: 1;
                transform: translateY(-40px);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }
        
        .score-popup {
            position: absolute;
            color: white;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            z-index: 50;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
            animation: score-float 0.9s ease-out;
            transform-origin: center;
            white-space: nowrap;
        }
        
        .score-popup.large-score {
            font-size: 22px;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7), 0 0 5px rgba(0, 0, 0, 0.9);
        }
        
        .score-popup.mega-score {
            font-size: 26px;
            color: #ff5e3a;
            text-shadow: 0 0 15px rgba(255, 94, 58, 0.8), 0 0 5px rgba(0, 0, 0, 0.9);
            animation: score-float 0.9s ease-out, pop 0.3s ease-in-out;
        }
            .msg.show {
                opacity: 1
            }

        #resultPopup {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.65);
            z-index: 999;
            visibility: hidden;
            opacity: 0;
            transition: opacity .25s;
        }

            #resultPopup.show {
                visibility: visible;
                opacity: 1
            }

        #resultBox {
            background: #161c29;
            padding: 24px;
            border-radius: 16px;
            text-align: center;
            min-width: 360px;
            max-width: 96vw;
            box-shadow: 0 10px 28px rgba(0,0,0,0.6);
        }

            #resultBox h2 {
                margin: 0 0 8px;
                font-size: 20px;
            }

            #resultBox p {
                margin: 6px 0;
                font-size: 14px;
                color: var(--muted);
            }

            #resultBox .btn {
                margin-top: 12px;
            }

        #rankHeader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        #rankings {
            margin-top: 10px;
            max-height: 320px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid #2a3443;
            border-radius: 10px;
        }

        .rank-item {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            padding: 6px 10px;
            border-bottom: 1px solid #222a3b;
            font-size: 14px;
            gap: 10px;
        }

            .rank-item .left {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .rank-item .right {
                display: flex;
                align-items: center;
                gap: 6px;
            }

            .rank-item .score {
                min-width: 60px;
                text-align: right;
            }

            .rank-item .btn {
                font-size: 12px;
                padding: 2px 6px;
                height: 22px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                position: relative;
                top: -6px;
            }

        .crown {
            font-size: 16px;
            line-height: 1
        }

        .top1 .crown {
            color: gold;
            filter: drop-shadow(0 0 6px rgba(255,215,0,.35))
        }

        .top2 .crown {
            color: silver;
            filter: drop-shadow(0 0 6px rgba(192,192,192,.3))
        }

        .top3 .crown {
            color: #cd7f32;
            filter: drop-shadow(0 0 6px rgba(205,127,50,.3))
        }

        #noMovesMsg {
            margin-top: 8px;
            font-size: 13px;
            color: var(--warn);
        }
        
        /* ë³´ìƒ ì„ íƒ íŒì—… ìŠ¤íƒ€ì¼ */
        #rewardPopup {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.65);
            z-index: 999;
            visibility: hidden;
            opacity: 0;
            transition: opacity .25s;
        }
        
        #rewardPopup.show {
            visibility: visible;
            opacity: 1;
        }
        
        #rewardBox {
            background: #161c29;
            padding: 24px;
            border-radius: 16px;
            text-align: center;
            min-width: 360px;
            max-width: 96vw;
            box-shadow: 0 10px 28px rgba(0,0,0,0.6);
        }
        
        #rewardBox h2 {
            margin: 0 0 8px;
            font-size: 20px;
            color: var(--accent);
        }
        
        #rewardBox p {
            margin: 6px 0 20px;
            font-size: 15px;
            color: var(--fg);
        }
        
        .reward-options {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }
        
        .reward-option {
            width: 80px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-radius: 10px;
            background: #1c2336;
            border: 2px solid #2a3443;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .reward-option:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(70, 211, 255, 0.4);
            border-color: var(--accent);
        }
        
        .reward-icon {
            width: 50px;
            height: 50px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .undo-icon {
            background-image: url('images/undo-icon.png');
            filter: drop-shadow(0 0 5px rgba(70, 211, 255, 0.7));
        }
        
        .block-removal-icon {
            background-image: url('images/block-removal-icon.png');
            filter: drop-shadow(0 0 5px rgba(103, 255, 154, 0.7));
        }
        
        .monster-spawn-icon {
            background-image: url('images/monster-spawn-icon.png');
            filter: drop-shadow(0 0 5px rgba(255, 136, 77, 0.7));
        }
        
        .wildcard-spawn-icon {
            background-image: url('images/wildcard-icon.png');
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.7));
        }
        
        .reward-name {
            font-size: 12px;
            font-weight: 500;
            margin-top: 8px;
            color: #cfe5ff;
        }
    </style>
</head>
<body>
    <header>
        <div id="title">3ê°œì˜ ëª¬ìŠ¤í„°ë¥¼ í•©ì¹˜ì„¸ìš”</div>
        <div class="stat">
            <span class="idtag" id="idView">ID: -</span>
            <span>í„´: <b id="turn">0</b></span>
            <span>ë‹¤ìŒ ì†Œí™˜: <b id="nextSpawn">3</b></span>
            <span>ëŒ€ì†Œí™˜ ë‚¨ìŒ: <b id="megaLeft">5</b></span>
            <span>ë°©í•´ ë¸”ëŸ­ ë‚¨ìŒ: <b id="blockLeft">7</b></span>
            <span id="version">v1.5.0</span>
        </div>
    </header>
    <div id="boardWrap">
        <div id="board"></div>
        <div id="controlBar">
            <button class="btn" id="btnNew">ìƒˆ ê²Œì„</button>
            <button class="btn" id="btnUndo">ë˜ëŒë¦¬ê¸° (3íšŒ)</button>
            <button class="btn" id="btnResetId">ì•„ì´ë”” ì´ˆê¸°í™”</button>
            <button class="btn" id="btnRankManual">ë­í‚¹ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            <button class="btn" id="btnBlockRemoval">ë¸”ë¡ ì œê±° (3íšŒ)</button>
            <button class="btn" id="btnSpawnMonster">ëª¬ìŠ¤í„° ì†Œí™˜ (5íšŒ)</button>
            <button class="btn" id="btnSpawnWildcard">ì¡°ì»¤ ì†Œí™˜ (2íšŒ)</button>
        </div>
    </div>
    <div class="msg" id="toast"></div>
    <div id="resultPopup">
        <div id="resultBox">
            <h2 id="popupTitle">ê²Œì„ ì˜¤ë²„</h2>
            <p id="finalScore"></p>
            <p id="noMovesMsg" style="display:none;">ì´ë™ ê°€ëŠ¥í•œ ì†Œí™˜ìˆ˜ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
            <div id="rankHeader"><h3 style="margin:0;font-size:16px;">ë­í‚¹ TOP 100</h3></div>
            <div id="rankings"><div style="padding:10px">ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ì¤‘...</div></div>
            <div style="margin-top:12px;display:flex;gap:8px;justify-content:center;">
                <button class="btn" id="btnRestart">ë‹¤ì‹œ ì‹œì‘</button>
                <button class="btn" id="btnBack">ëŒì•„ê°€ê¸°</button>
                <button class="btn" id="btnViewBest">ë‚´ ìµœê³  ê¸°ë¡ í™•ì¸</button>
            </div>
        </div>
    </div>
    <div id="rewardPopup">
        <div id="rewardBox">
            <h2>ë³´ìƒ ì„ íƒ</h2>
            <p>ë³‘í•© ì„±ê³µ! ë³´ìƒì„ ì„ íƒí•˜ì„¸ìš”</p>
            <div class="reward-options">
                <div class="reward-option" data-type="undo">
                    <div class="reward-icon undo-icon"></div>
                    <div class="reward-name">ë˜ëŒë¦¬ê¸°</div>
                </div>
                <div class="reward-option" data-type="blockRemoval">
                    <div class="reward-icon block-removal-icon"></div>
                    <div class="reward-name">ë¸”ë¡ ì œê±°</div>
                </div>
                <div class="reward-option" data-type="monsterSpawn">
                    <div class="reward-icon monster-spawn-icon"></div>
                    <div class="reward-name">ëª¬ìŠ¤í„° ì†Œí™˜</div>
                </div>
                <div class="reward-option" data-type="wildcardSpawn">
                    <div class="reward-icon wildcard-spawn-icon"></div>
                    <div class="reward-name">ì¡°ì»¤ ì†Œí™˜</div>
                </div>
            </div>
        </div>
    </div>
    <script>
        (() => {
            /* ====== ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ ====== */
            function preloadImages(urls) {
                return Promise.all(urls.map(src => new Promise(res => {
                    const img = new Image();
                    img.onload = res;
                    img.onerror = res;
                    img.src = src;
                })));
            }
            const IMAGE_URLS = [
                "images/block-1.png", "images/block-2.png", "images/block-3.png",
                "images/block-4.png", "images/block-5.png", "images/block-6.png",
                "images/block-7.png", "images/block-8.png", "images/block-9.png",
                "images/blocked.png", "images/empty.png", "images/bg.png", "images/wildcard.png"
            ];

            /* ====== ğŸµ ì‚¬ìš´ë“œ ë¡œë“œ ====== */
            window.sounds = {
                bgm: new Audio("sounds/bgm.mp3"),
                move: new Audio("sounds/move.mp3"),
                click: new Audio("sounds/click.mp3"),
                toast: new Audio("sounds/toast.mp3"),
                gameover: new Audio("sounds/gameover.mp3"),
                block: new Audio("sounds/click.mp3"), // ë°©í•´ ë¸”ë¡ ìƒì„± ì‚¬ìš´ë“œ (ì„ì‹œë¡œ click.mp3 ì‚¬ìš©)
                special: {
                    megaMerge: new Audio("sounds/block-8.mp3") // í° ë³‘í•©ì„ ìœ„í•œ íŠ¹ë³„ íš¨ê³¼ìŒ
                },
                blocks: {
                    3: new Audio("sounds/block-2.mp3"),
                    9: new Audio("sounds/block-3.mp3"),
                    27: new Audio("sounds/block-4.mp3"),
                    81: new Audio("sounds/block-5.mp3"),
                    243: new Audio("sounds/block-6.mp3"),
                    729: new Audio("sounds/block-7.mp3"),
                    2187: new Audio("sounds/block-8.mp3"),
                    6561: new Audio("sounds/block-9.mp3")
                }
            };


            // ì˜¤ë””ì˜¤ ì˜¤ë¥˜ ë°©ì§€ í•¨ìˆ˜ - ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
            window.playSoundSafely = function(sound) {
                if (!sound) return;
                
                try {
                    // ì‚¬ìš´ë“œ ì¬ìƒ ì‹œë„
                    const playPromise = sound.play();
                    
                    // í”„ë¡œë¯¸ìŠ¤ ì²˜ë¦¬
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            // ì˜¤ë¥˜ ë°œìƒì‹œ ë¬´ì‹œ
                            console.warn('Sound play failed:', error);
                        });
                    }
                } catch (e) {
                    console.warn('Sound playback error:', e);
                }
            };
            
            // ì‚¬ìš´ë“œ ë¡œë”© ê²€ì‚¬
            function validateSounds() {
                // ê¸°ë³¸ ì‚¬ìš´ë“œ ê²€ì‚¬
                const soundKeys = ['bgm', 'move', 'click', 'toast', 'gameover'];
                for (const key of soundKeys) {
                    if (!sounds[key].src || sounds[key].error) {
                        console.warn(`Sound '${key}' failed to load. Using empty audio.`);
                        sounds[key] = new Audio(); // ë¹ˆ ì˜¤ë””ì˜¤ë¡œ ëŒ€ì²´
                    }
                }
                
                // íŠ¹ìˆ˜ ì‚¬ìš´ë“œ ê²€ì‚¬
                if (!sounds.special.megaMerge.src || sounds.special.megaMerge.error) {
                    console.warn('Special sound megaMerge failed to load. Using empty audio.');
                    sounds.special.megaMerge = new Audio();
                }
                
                // ë¸”ë¡ ì‚¬ìš´ë“œ ê²€ì‚¬
                for (const key in sounds.blocks) {
                    if (!sounds.blocks[key].src || sounds.blocks[key].error) {
                        console.warn(`Block sound ${key} failed to load. Using empty audio.`);
                        sounds.blocks[key] = new Audio();
                    }
                }
            }
            
            // ë£¨í”„ & ë³¼ë¥¨
            sounds.bgm.loop = true;
            sounds.bgm.volume = 1;
            sounds.move.volume = 1;
            sounds.click.volume = 1;
            sounds.toast.volume = 1;
            sounds.gameover.volume = 1;
            for (let k in sounds.blocks) sounds.blocks[k].volume = 1;
            
            // ì‚¬ìš´ë“œ ê²€ì‚¬
            validateSounds();


            /* ====== ê¸°ë³¸ ì„¤ì • ====== */
            const GAS_URL = "https://script.google.com/macros/s/AKfycbzdvX2sII9CetZq4SHnThBLZSM9T9VHLw1Oqo6RvQbWrf_xBITGMqmfdzFFYIWd6Qrn/exec";
            const COLS = 5, ROWS = 7;
            const INIT_TILES = 12;
            const BLOCK_MIN = 3, BLOCK_MAX = 3;
            const SPAWN_EVERY = 3;
            const SPAWN_BATCH = 3;
            const MEGA_INTERVAL = 5;
            const BLOCK_SPAWN_INTERVAL = 7;
            const WILDCARD_TILE = -2; // íŠ¹ìˆ˜ ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ (ëª¨ë“  íƒ€ì¼ê³¼ ë§¤ì¹­ ê°€ëŠ¥)
            const WILDCARD_SPAWN_CHANCE = 0.05; // ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ ë“±ì¥ í™•ë¥  (5%)
            
            // ì•„ì´í…œ í™•ë¥  ì„¤ì •
            const ITEM_SPAWN_CHANCE_FALSE = 0.0; // falseê°€ ì „ë‹¬ë  ë•Œ ì•„ì´í…œ ë“±ì¥ í™•ë¥  (0%)
            const ITEM_SPAWN_CHANCE_TRUE = 0.1;  // trueê°€ ì „ë‹¬ë  ë•Œ ì•„ì´í…œ ë“±ì¥ í™•ë¥  (0%)
            
            // í•©ì„± ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
            const MERGE_ANIMATION_DURATION = 600; // ms
            const MERGE_HIGHLIGHT_DURATION = 300; // ms
            const MERGE_ABSORB_DURATION = 400; // ms
            const MERGE_COMPLETE_DURATION = 220; // ms
            
            // ë³´ë„ˆìŠ¤ ì ìˆ˜ ì„¤ì •
            const BONUS_THRESHOLD = 3;      // 3ê°œ ì´ìƒ í•©ì„±ë¶€í„° ë³´ë„ˆìŠ¤
            const MEGA_BONUS_THRESHOLD = 5;  // 5ê°œ ì´ìƒ í•©ì„±ë¶€í„° ë©”ê°€ ë³´ë„ˆìŠ¤

            // ë¸”ëŸ­ ì´ë¯¸ì§€ ë§¤í•‘
            const TILE_IMAGES = {
                1: "images/block-1.png", 3: "images/block-2.png", 9: "images/block-3.png",
                27: "images/block-4.png", 81: "images/block-5.png", 243: "images/block-6.png",
                729: "images/block-7.png", 2187: "images/block-8.png", 6561: "images/block-9.png",
                [WILDCARD_TILE]: "images/wildcard.png" // ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ ì´ë¯¸ì§€
            };

            let grid = [], tileItems = {}, turn = 0, untilSpawn = SPAWN_EVERY, spawnCount = 0, blockSpawnTurn = BLOCK_SPAWN_INTERVAL, selected = null, history = [], gameOverShown = false;
            let lastGameState = null, bestScore = 0, bestGameState = null;
            let isAnimating = false;  // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘ í”Œë˜ê·¸
            let activeScorePopups = []; // í™œì„±í™”ëœ ì ìˆ˜ íŒì—…
            let blockRemovalMode = false; // ë¸”ë¡ ì œê±° ëª¨ë“œ í™œì„±í™” ì—¬ë¶€
            let blockRemovalUsesLeft = 3; // ë‚¨ì€ ë¸”ë¡ ì œê±° íšŸìˆ˜
            
            // ë˜ëŒë¦¬ê¸°, ì†Œí™˜ ê¸°ëŠ¥ ì œí•œ íšŸìˆ˜ ê´€ë ¨ ë³€ìˆ˜
            let undoUsesLeft = 3; // ë‚¨ì€ ë˜ëŒë¦¬ê¸° íšŸìˆ˜
            let monsterSpawnUsesLeft = 5; // ë‚¨ì€ ëª¬ìŠ¤í„° ì†Œí™˜ íšŸìˆ˜
            let wildcardSpawnUsesLeft = 2; // ë‚¨ì€ ì¡°ì»¤ ì†Œí™˜ íšŸìˆ˜
            
            // ë¸”ë¡ ì œê±° ë²„íŠ¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateBlockRemovalButton() {
                const btn = document.getElementById('btnBlockRemoval');
                
                if (blockRemovalUsesLeft <= 0) {
                    btn.textContent = "ë¸”ë¡ ì œê±° (ì™„ë£Œ)";
                    btn.disabled = true;
                    btn.style.opacity = "0.5";
                    blockRemovalMode = false;
                } else {
                    btn.textContent = `ë¸”ë¡ ì œê±° (${blockRemovalUsesLeft}íšŒ)`;
                    btn.disabled = false;
                    btn.style.opacity = "1";
                    
                    // í™œì„±í™”ëœ ëª¨ë“œ ìƒíƒœ í‘œì‹œ
                    if (blockRemovalMode) {
                        btn.style.background = "#2a4d6e";
                        btn.style.borderColor = "#46d3ff";
                        btn.style.boxShadow = "0 0 8px rgba(70, 211, 255, 0.5)";
                    } else {
                        btn.style.background = "#121722";
                        btn.style.borderColor = "#2a3443";
                        btn.style.boxShadow = "none";
                    }
                }
            }
            
            // ë˜ëŒë¦¬ê¸° ë²„íŠ¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateUndoButton() {
                const btnUndo = document.getElementById('btnUndo');
                if (!btnUndo) return;
                
                // íˆìŠ¤í† ë¦¬ê°€ ì—†ê±°ë‚˜ ë‚¨ì€ íšŸìˆ˜ê°€ 0ì´ë©´ ë¹„í™œì„±í™”
                if (history.length === 0 || undoUsesLeft <= 0) {
                    btnUndo.disabled = true;
                    btnUndo.style.opacity = "0.5";
                    
                    // íšŸìˆ˜ì— ë”°ë¥¸ í…ìŠ¤íŠ¸ ì„¤ì •
                    if (undoUsesLeft <= 0) {
                        btnUndo.textContent = `ë˜ëŒë¦¬ê¸° (ì™„ë£Œ)`;
                    } else {
                        btnUndo.textContent = `ë˜ëŒë¦¬ê¸° (${undoUsesLeft}íšŒ)`;
                    }
                } else {
                    btnUndo.disabled = false;
                    btnUndo.style.opacity = "1";
                    btnUndo.textContent = `ë˜ëŒë¦¬ê¸° (${undoUsesLeft}íšŒ)`;
                }
            }
            
            // ëª¬ìŠ¤í„° ì†Œí™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateMonsterSpawnButton() {
                const btn = document.getElementById('btnSpawnMonster');
                if (!btn) return;
                
                if (monsterSpawnUsesLeft <= 0) {
                    btn.textContent = "ëª¬ìŠ¤í„° ì†Œí™˜ (ì™„ë£Œ)";
                    btn.disabled = true;
                    btn.style.opacity = "0.5";
                } else {
                    btn.textContent = `ëª¬ìŠ¤í„° ì†Œí™˜ (${monsterSpawnUsesLeft}íšŒ)`;
                    btn.disabled = false;
                    btn.style.opacity = "1";
                }
            }
            
            // ì¡°ì»¤ ì†Œí™˜ ë²„íŠ¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
            function updateWildcardSpawnButton() {
                const btn = document.getElementById('btnSpawnWildcard');
                if (!btn) return;
                
                if (wildcardSpawnUsesLeft <= 0) {
                    btn.textContent = "ì¡°ì»¤ ì†Œí™˜ (ì™„ë£Œ)";
                    btn.disabled = true;
                    btn.style.opacity = "0.5";
                } else {
                    btn.textContent = `ì¡°ì»¤ ì†Œí™˜ (${wildcardSpawnUsesLeft}íšŒ)`;
                    btn.disabled = false;
                    btn.style.opacity = "1";
                }
            }
            
            // ëª¨ë“  ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            function updateAllButtons() {
                updateBlockRemovalButton();
                updateUndoButton();
                updateMonsterSpawnButton();
                updateWildcardSpawnButton();
            }

            const board = document.getElementById('board');
            const elTurn = document.getElementById('turn'),
                elNext = document.getElementById('nextSpawn'),
                elMega = document.getElementById('megaLeft'),
                elBlock = document.getElementById('blockLeft');
            const toast = document.getElementById('toast');
            let toastTimer = null;

            function info(t, k) {
                // ì¤‘ë³µ ë©”ì‹œì§€ ì²˜ë¦¬ ë°©ì§€
                if (toast.textContent === t && toast.classList.contains('show')) {
                    return;
                }
                
                toast.textContent = t;
                toast.style.color =
                    k === 'err' ? 'var(--err)' :
                        (k === 'warn' ? 'var(--warn)' : 'var(--fg)');

                // show ì¬ì ìš©
                toast.classList.remove('show');
                void toast.offsetWidth;
                toast.classList.add('show');

                // ğŸµ ì•ˆë‚´ë¬¸êµ¬ìŒ
                sounds.toast.currentTime = 0;
                playSoundSafely(sounds.toast);

                if (toastTimer) clearTimeout(toastTimer);
                toastTimer = setTimeout(() => {
                    toast.classList.remove('show');
                    toastTimer = null;
                }, 2000);
            }

            const popup = document.getElementById('resultPopup'),
                finalScore = document.getElementById('finalScore'),
                popupTitle = document.getElementById('popupTitle');
            const idView = document.getElementById('idView');
            const rankingsEl = document.getElementById('rankings');
            const noMovesMsg = document.getElementById('noMovesMsg');
            /* ====== ì•„ì´ë”” ====== */
            let playerId = localStorage.getItem("mergePlayerId");
            function askPlayerId(force = false) {
                if (!playerId || force) {
                    let input = "";
                    while (!input) {
                        input = prompt("í”Œë ˆì´ì–´ ì•„ì´ë””ë¥¼ ì…ë ¥í•˜ì„¸ìš”:");
                        if (input === null) { input = ""; }
                    }
                    playerId = input.trim();
                    localStorage.setItem("mergePlayerId", playerId);
                    info(`ì•„ì´ë”” ì„¤ì •ë¨: ${playerId}`);
                }
                idView.textContent = "ID: " + playerId;
            }

            /* ====== ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ í•¨ìˆ˜ ====== */
            function createParticles(x, y, count = 10, sizeFactor = 1) {
                // ë§¤ì¹˜ ë°œìƒ ìœ„ì¹˜ì—ì„œ íŒŒí‹°í´ íš¨ê³¼ ìƒì„±
                // ìƒëŒ€ì  ìœ„ì¹˜ê°€ ì•„ë‹Œ ì ˆëŒ€ì  ì¢Œí‘œ ì‚¬ìš©
                const container = document.querySelector('.game-container');
                
                // ì»¨í…Œì´ë„ˆê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì˜ˆì™¸ ì²˜ë¦¬
                if (!container) {
                    // ì»¨í…Œì´ë„ˆê°€ ì—†ìœ¼ë©´ ê·¸ëŒ€ë¡œ ì¢Œí‘œ ì‚¬ìš©
                    // ì ˆëŒ€ ì¢Œí‘œë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ document.bodyì— ì¶”ê°€
                } else {
                    // ê²Œì„ ì˜ì—­ì´ ìˆëŠ” ê²½ìš° ìƒëŒ€ì  ì¢Œí‘œ ê³„ì‚°
                    const rect = container.getBoundingClientRect();
                    x = x + rect.left;
                    y = y + rect.top;
                }
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // í¬ê¸° ëœë¤í™”
                    const size = (4 + Math.random() * 8) * sizeFactor;
                    particle.style.width = size + 'px';
                    particle.style.height = size + 'px';
                    
                    // ì´ˆê¸° ìœ„ì¹˜
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    
                    // ì´ë™ ë°©í–¥ ëœë¤í™”
                    const tx = (Math.random() - 0.5) * 100;
                    const ty = (Math.random() - 0.5) * 100;
                    particle.style.setProperty('--tx', tx + 'px');
                    particle.style.setProperty('--ty', ty + 'px');
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
                    const duration = 0.5 + Math.random() * 0.7;
                    particle.style.animation = `particle-float ${duration}s ease-out forwards`;
                    
                    // ìƒ‰ìƒ ëœë¤í™”
                    const hue = Math.random() * 60 + 30; // í™©ê¸ˆìƒ‰ ê³„ì—´
                    particle.style.backgroundColor = `hsla(${hue}, 100%, 70%, 0.8)`;
                    particle.style.boxShadow = `0 0 ${size}px hsla(${hue}, 100%, 50%, 0.6)`;
                    
                    document.body.appendChild(particle);
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ìš”ì†Œ ì œê±°
                    setTimeout(() => particle.remove(), duration * 1000);
                }
            }
            
            /* ====== ìœ í‹¸ ====== */
            function cloneGrid(g) { return g.map(r => r.slice()); }
            function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
            function isEmpty(r, c) { return grid[r][c] === 0; }
            function isBlocked(r, c) { return grid[r][c] === -1; }
            function isTile(r, c) { return grid[r][c] > 0 || grid[r][c] === WILDCARD_TILE; }
            function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]]; } }
            function listEmpty() { const out = []; for (let r = 0; r < ROWS; r++)for (let c = 0; c < COLS; c++)if (grid[r][c] === 0) out.push({ r, c }); return out; }
            
            // íƒ€ì¼ ì•„ì´í…œ ê´€ë¦¬ í•¨ìˆ˜
            function hasItem(r, c) {
                const key = `${r},${c}`;
                return tileItems[key] === true;
            }
            
            function setItem(r, c, hasItem = true) {
                const key = `${r},${c}`;
                // í™•ë¥ ì— ê¸°ë°˜í•œ ì•„ì´í…œ ì„¤ì •
                const probability = hasItem ? ITEM_SPAWN_CHANCE_TRUE : ITEM_SPAWN_CHANCE_FALSE;
                const shouldHaveItem = Math.random() < probability;
                
                if (shouldHaveItem) {
                    tileItems[key] = true;
                } else {
                    delete tileItems[key];
                }
            }
            
            function moveItem(fromR, fromC, toR, toC) {
                const fromKey = `${fromR},${fromC}`;
                const toKey = `${toR},${toC}`;
                
                if (tileItems[fromKey]) {
                    tileItems[toKey] = true;
                    delete tileItems[fromKey];
                    return true;
                }
                return false;
            }
            
            function clearItems() {
                tileItems = {};
            }
            /**
             * Checks if a tile at a specific position has any legal moves in the given grid state
             * 
             * @param {number} r - Row index of the tile to check
             * @param {number} c - Column index of the tile to check
             * @param {Array<Array<number>>} g - The grid state to check against
             * @returns {boolean} - True if the tile has at least one legal move, false otherwise
             */
            function hasAnyLegalMove(r, c, g) {
              // Check if a tile at position (r,c) has any legal moves
              const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
              const val = g[r][c];
              
              for (const [dr, dc] of dirs) {
                const nr = r + dr, nc = c + dc;
                if (!inBounds(nr, nc)) continue;
                
                // Can move to empty cells
                if (g[nr][nc] === 0) return true;
                
                // Check for potential merges
                if (g[nr][nc] > 0 && g[nr][nc] === val) return true;
                if (g[nr][nc] === WILDCARD_TILE || val === WILDCARD_TILE) return true;
              }
              
              return false;
            }
            
            /**
             * Checks if a blocked tile at the specified position can be removed
             * without making the game unwinnable
             * 
             * @param {number} r - Row index of the blocked tile to check
             * @param {number} c - Column index of the blocked tile to check
             * @returns {boolean} - True if the block can be removed safely, false otherwise
             */
            function isBlockRemovable(r, c) {
              // Check if the position actually contains a blocked tile
              if (!isBlocked(r, c)) return false;
              
              // Create a simulated grid with the block removed
              const simGrid = cloneGrid(grid);
              simGrid[r][c] = 0; // Remove the block temporarily
              
              // Find all tiles on the board
              const tiles = [];
              for (let sr = 0; sr < ROWS; sr++) {
                for (let sc = 0; sc < COLS; sc++) {
                  if (simGrid[sr][sc] > 0 || simGrid[sr][sc] === WILDCARD_TILE) {
                    tiles.push({r: sr, c: sc});
                  }
                }
              }
              
              // If there are no tiles, removing the block is always safe
              if (tiles.length === 0) return true;
              
              // Check if all tiles still have at least one valid move after block removal
              for (const tile of tiles) {
                if (!hasAnyLegalMove(tile.r, tile.c, simGrid)) {
                  return false; // This tile would be stuck if we remove this block
                }
              }
              
              return true; // All tiles still have moves, safe to remove
            }

            /**
             * Validates whether a blocked tile can be created at the specified position
             * without making the game unwinnable
             * 
             * @param {number} r - Row index of the cell to check
             * @param {number} c - Column index of the cell to check
             * @returns {boolean} - True if a blocked tile can be created, false otherwise
             */
            function canCreateBlockedTile(r, c) {
              // Create a simulated grid with the new blocked tile
              const simGrid = cloneGrid(grid);
              simGrid[r][c] = -1;
              
              // Find all tiles on the board
              const tiles = [];
              for (let sr = 0; sr < ROWS; sr++) {
                for (let sc = 0; sc < COLS; sc++) {
                  if (simGrid[sr][sc] > 0 || simGrid[sr][sc] === WILDCARD_TILE) {
                    tiles.push({r: sr, c: sc});
                  }
                }
              }
              
              // Check if all tiles have at least one valid move
              for (const tile of tiles) {
                if (!hasAnyLegalMove(tile.r, tile.c, simGrid)) {
                  return false;
                }
              }
              
              return true;
            }
            
            /**
             * Toggles a cell between blocked state and empty state
             * 
             * @param {number} r - Row index of the cell to toggle
             * @param {number} c - Column index of the cell to toggle
             * @param {boolean} removalOnly - If true, only removal of blocks is allowed, not creation
             * @returns {boolean} - True if the toggle was successful, false otherwise
             */
            function toggleBlockedTile(r, c, removalOnly = false) {
              if (!inBounds(r, c)) return false;
              
              // ë¸”ë¡ ì œê±° ëª¨ë“œì´ë©´ ì´ë¯¸ ì„¤ì¹˜ëœ ë¸”ë¡ë§Œ ì œê±°í•  ìˆ˜ ìˆìŒ
              if (removalOnly) {
                if (!isBlocked(r, c)) {
                  info("ë¸”ë¡ ì œê±° ëª¨ë“œ: ì œê±°í•  ë¸”ë¡ì„ ì„ íƒí•˜ì„¸ìš”.", "warn");
                  return false;
                }
                
                // ë¸”ë¡ ì œê±°
                grid[r][c] = 0;
                drawCell(r, c);
                
                // ë¸”ë¡ ì œê±° íšŸìˆ˜ ê°ì†Œ - ë¸”ë¡ ì œê±° ëª¨ë“œì—ì„œ ë§ˆë‹¤ ê°ì†Œ ì²˜ë¦¬
                blockRemovalUsesLeft--;
                updateBlockRemovalButton();
                
                // ë‚¨ì€ íšŸìˆ˜ ì—†ìœ¼ë©´ ëª¨ë“œ ì¢…ë£Œ
                if (blockRemovalUsesLeft <= 0) {
                  blockRemovalMode = false;
                  info("ë¸”ë¡ ì œê±° ê¸°ëŠ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ëª¨ë“œê°€ ì¢…ë£Œë©ë‹ˆë‹¤.", "warn");
                  
                  // ë¸”ë¡ ì œê±° ëª¨ë“œ ì‹œê° íš¨ê³¼ ì œê±°
                  clearRemovableBlocks();
                  document.body.style.cursor = '';
                } else {
                  // ì•„ì§ ë‚¨ì€ íšŸìˆ˜ê°€ ìˆìœ¼ë©´ ì‹œê°í™”ë¥¼ ë‹¤ì‹œ ì—…ë°ì´íŠ¸
                  showRemovableBlocks();
                }
                
                // íš¨ê³¼ìŒ ì¬ìƒ
                sounds.click.currentTime = 0;
                playSoundSafely(sounds.click);
                
                return true;
              }
              
              // ì¼ë°˜ ëª¨ë“œì—ì„œëŠ” ë¹ˆ ì…€ì´ë‚˜ ë¸”ë¡ ì…€ë§Œ í† ê¸€ ê°€ëŠ¥
              if (!(isEmpty(r, c) || isBlocked(r, c))) return false;
              
              // Toggle the state
              const newState = isBlocked(r, c) ? 0 : -1;
              
              // ë¸”ë¡ ì œê±° ì²˜ë¦¬
              if (isBlocked(r, c) && newState === 0) {
                // ë¸”ë¡ ì œê±° íšŸìˆ˜ ê°ì†Œ - ì¼ë°˜ ëª¨ë“œì—ì„œë„ ë¸”ë¡ ì œê±°ì‹œ íšŸìˆ˜ ì°¨ê°
                blockRemovalUsesLeft--;
                updateBlockRemovalButton();
                
                // ë‚¨ì€ íšŸìˆ˜ ì—†ìœ¼ë©´ ê´€ë ¨ ì²˜ë¦¬
                if (blockRemovalUsesLeft <= 0) {
                  info("ë¸”ë¡ ì œê±° ê¸°ëŠ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.", "warn");
                }
              }
              
              // Validate the change won't create an unwinnable state
              if (newState === -1 && !canCreateBlockedTile(r, c)) {
                info("ë¸”ë¡ ì„¤ì¹˜ ë¶ˆê°€: ì´ ìœ„ì¹˜ì— ë¸”ë¡ì„ ì„¤ì¹˜í•˜ë©´ ê²Œì„ì´ ë¶ˆê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.", "err");
                return false;
              }
              
              // Apply the change
              grid[r][c] = newState;
              drawCell(r, c);
              
              // Play effect
              sounds.click.currentTime = 0;
              playSoundSafely(sounds.click);
              
              return true;
            }
            function randomValue() {
                // ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ ë“±ì¥ í™•ë¥  í™•ì¸ (5%)
                if (Math.random() < WILDCARD_SPAWN_CHANCE) {
                    return WILDCARD_TILE;
                }
                // ê¸°ì¡´ ì¼ë°˜ íƒ€ì¼ ë¡œì§
                return [1, 1, 1, 1, 3, 3, 9][(Math.random() * 7) | 0];
            }
            
            // ì™€ì¼ë“œì¹´ë“œë¥¼ ì œì™¸í•œ ì¼ë°˜ ëª¬ìŠ¤í„°ë§Œ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
            function randomValueNoWildcard() {
                // ì¼ë°˜ ëª¬ìŠ¤í„°ë§Œ ëœë¤ ìƒì„± (ì™€ì¼ë“œì¹´ë“œ ì œì™¸)
                return [1, 1, 1, 1, 3, 3, 9][(Math.random() * 7) | 0];
            }

            /* ====== ì…€ & ë Œë”ë§ ====== */
            function drawCell(r, c, opt = {}) {
                const idx = r * COLS + c, cell = board.children[idx];
                cell.classList.toggle('blocked', isBlocked(r, c));
                const prev = cell.querySelector('.tile'); if (prev) prev.remove();
                const v = grid[r][c];
                if (v > 0 || v === WILDCARD_TILE) {
                    const t = document.createElement('div');
                    t.className = 'tile'; t.dataset.val = v;
                    if (opt.spawn) t.classList.add('spawn');
                    // ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ì€ íŠ¹ë³„í•œ íš¨ê³¼ ì¶”ê°€
                    if (v === WILDCARD_TILE) {
                        t.classList.add('wildcard');
                    }
                    
                    // ì•„ì´í…œ ë³´ìœ  í‘œì‹œ - ì•„ì´í…œì´ ìˆëŠ” íƒ€ì¼ì€ íŠ¹ë³„í•œ íš¨ê³¼ ì¶”ê°€
                    if (hasItem(r, c)) {
                        t.dataset.hasItem = 'true';
                        // ë°˜ì§ì´ëŠ” í…Œë‘ë¦¬ íš¨ê³¼ ì¶”ê°€ (ì¶”í›„ ì¶”ê°€ ê°€ëŠ¥)
                    }
                    
                    if (TILE_IMAGES[v]) t.style.backgroundImage = `url(${TILE_IMAGES[v]})`;
                    cell.appendChild(t);
                } else if (v === -1) {
                    const b = document.createElement('div');
                    b.className = 'tile';
                    b.style.backgroundImage = "url('images/blocked.png')";
                    cell.appendChild(b);
                } else {
                    const e = document.createElement('div');
                    e.className = 'tile';
                    e.style.backgroundImage = "url('images/empty.png')";
                    cell.appendChild(e);
                }
            }
            function renderAll(spawn = false) {
                for (let r = 0; r < ROWS; r++)for (let c = 0; c < COLS; c++)
                    drawCell(r, c, { spawn: spawn && isTile(r, c) });
                elTurn.textContent = String(turn);
                elNext.textContent = String(untilSpawn);
                elMega.textContent = String(MEGA_INTERVAL - (spawnCount % MEGA_INTERVAL || MEGA_INTERVAL));
                elBlock.textContent = String(blockSpawnTurn);
            }
            function highlightSelection() {
                for (const cell of board.children) {
                    const t = cell.querySelector('.tile'); if (t) t.classList.remove('sel');
                }
                if (selected) {
                    const tile = board.children[selected.r * COLS + selected.c].querySelector('.tile');
                    if (tile) tile.classList.add('sel');
                }
            }
            
            /* ====== ì´ë™ ê°€ëŠ¥ ìœ„ì¹˜ í‘œì‹œ ê¸°ëŠ¥ ì¶”ê°€ ====== */
                        function clearPossibleMoves() {
                            // ëª¨ë“  'possible-move' í´ë˜ìŠ¤ë¥¼ ì œê±°í•˜ì—¬ í•˜ì´ë¼ì´íŠ¸ë¥¼ ë”
                            board.querySelectorAll('.possible-move').forEach(el => el.classList.remove('possible-move'));
                            // ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ë„ í•¨ê»˜ ì œê±°
                            board.querySelectorAll('.path-highlight').forEach(el => el.classList.remove('path-highlight'));
                        }

            /* ====== ì œê±° ê°€ëŠ¥í•œ ë¸”ë¡ í‘œì‹œ ê¸°ëŠ¥ ====== */
                        function showRemovableBlocks() {
                            // ëª¨ë“  ë¸”ë¡ íƒ€ì¼ì„ ìˆœíšŒí•˜ë©° ì œê±° ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
                            for (let r = 0; r < ROWS; r++) {
                                for (let c = 0; c < COLS; c++) {
                                    if (isBlocked(r, c)) {
                                        const cellIndex = r * COLS + c;
                                        const cell = board.children[cellIndex];
                                        
                                        if (isBlockRemovable(r, c)) {
                                            // ì œê±° ê°€ëŠ¥í•œ ë¸”ë¡ - ì´ˆë¡ìƒ‰ ê°•ì¡°
                                            cell.classList.add('removable-block');
                                            cell.classList.remove('non-removable-block');
                                        } else {
                                            // ì œê±° ë¶ˆê°€ëŠ¥í•œ ë¸”ë¡ - íšŒìƒ‰ ì²˜ë¦¬
                                            cell.classList.add('non-removable-block');
                                            cell.classList.remove('removable-block');
                                        }
                                    }
                                }
                            }
                            
                            // ëª¨ë“œ í™œì„±í™” í‘œì‹œ ì¶”ê°€
                            document.getElementById('btnBlockRemoval').style.background = "#2a4d6e";
                            document.getElementById('btnBlockRemoval').style.borderColor = "#46d3ff";
                            document.getElementById('btnBlockRemoval').style.boxShadow = "0 0 8px rgba(70, 211, 255, 0.5)";
                        }

                        function clearRemovableBlocks() {
                            // ëª¨ë“  ë¸”ë¡ ê´€ë ¨ í•˜ì´ë¼ì´íŠ¸ í´ë˜ìŠ¤ ì œê±°
                            board.querySelectorAll('.removable-block').forEach(el => el.classList.remove('removable-block'));
                            board.querySelectorAll('.non-removable-block').forEach(el => el.classList.remove('non-removable-block'));
                            
                            // ëª¨ë“œ ë¹„í™œì„±í™” ì‹œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë³µì›
                            const btn = document.getElementById('btnBlockRemoval');
                            if (btn) {
                                btn.style.background = "#121722";
                                btn.style.borderColor = "#2a3443";
                                btn.style.boxShadow = "none";
                            }
                        }

                        function showPossibleMoves(r, c) {
                            // ì„ íƒí•œ ë¸”ë¡ì˜ ì •ë³´ë¥¼ ê°€ì ¸ì˜´
                            const val = grid[r][c];
                            // í˜„ì¬ íƒ€ì¼ê³¼ ì—°ê²°ëœ ëª¨ë“  íƒ€ì¼ì„ ì°¾ê¸° ìœ„í•´ maxSizeë¥¼ Infinityë¡œ ì„¤ì •
                            const currentGroup = floodSame(r, c, val, grid, Infinity);

                            // ëª¨ë“  ë¹„ì–´ìˆëŠ” ì¹¸ì„ ìˆœíšŒí•˜ë©° ì´ë™ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
                            for (let tr = 0; tr < ROWS; tr++) {
                                for (let tc = 0; tc < COLS; tc++) {
                                    if (!isEmpty(tr, tc)) continue;

                                    const to = { r: tr, c: tc };
                                    const from = { r, c };
                                    
                                    // ê¸°ì¡´ ì´ë™ ë¡œì§ì˜ ìœ íš¨ì„± ê²€ì‚¬ ì¡°ê±´ë“¤ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                                    const path = findPathViaEmpties(from, to);
                                    if (!path) continue;

                                    // ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ì€ íŠ¹ë³„í•œ ì²˜ë¦¬
                                    const gsize = groupSizeIfMoved(from, to, val);
                                    if (gsize < 2) continue;

                                    // í˜„ì¬ 2ê°œ ê·¸ë£¹ì„ ë¶„ë¦¬í•˜ëŠ” ê²½ìš°, 3ë§¤ì¹­ì´ ë˜ì–´ì•¼ í•¨
                                    // ì™€ì¼ë“œì¹´ë“œ ì˜ˆì™¸: ì™€ì¼ë“œì¹´ë“œëŠ” 2ê°œ ì´ìƒì˜ ê·¸ë£¹ì„ í˜•ì„±í•  ìˆ˜ ìˆìœ¼ë©´ 2ê·¸ë£¹ì—ì„œë„ ì´ë™ ê°€ëŠ¥
                                    if (currentGroup.length === 2 && gsize < 3) {
                                        // ì™€ì¼ë“œì¹´ë“œ ì˜ˆì™¸ ì²˜ë¦¬: ì™€ì¼ë“œì¹´ë“œëŠ” 2ê·¸ë£¹ ì´ìƒ í˜•ì„±í•˜ë©´ ì´ë™ í—ˆìš©
                                        if (val === WILDCARD_TILE && gsize >= 2) {
                                            // ì™€ì¼ë“œì¹´ë“œ ì˜ˆì™¸ ì ìš©: ì´ë™ í—ˆìš©
                                        } else {
                                            continue; // ì¼ë°˜ íƒ€ì¼ì€ ê¸°ì¡´ ê·œì¹™ ì ìš©
                                        }
                                    }

                                    // ëª¨ë“  ì¡°ê±´ì„ í†µê³¼í•˜ë©´ 'possible-move' í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•˜ì—¬ í•˜ì´ë¼ì´íŠ¸
                                    board.children[tr * COLS + tc].classList.add('possible-move');
                                }
                            }
                        }

            /* ====== ì´ˆê¸°í™” ====== */
            function init() {
                askPlayerId();
                board.innerHTML = '';
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell'; cell.dataset.r = r; cell.dataset.c = c;
                        cell.addEventListener('click', onTapCell);
                        board.appendChild(cell);
                    }
                }
                // ë¸”ë¡ ì œê±° ëª¨ë“œ ì´ˆê¸°í™”
                blockRemovalMode = false;
                blockRemovalUsesLeft = 3;
                updateBlockRemovalButton();
                
                // ëª¨ë“  ë²„íŠ¼ ì´ˆê¸° ìƒíƒœ ì„¤ì • (ì‚¬ìš© íšŸìˆ˜ í‘œì‹œ)
                updateAllButtons();
                
                newGame();
                // ëª¨ë“  ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì‚¬ìš© íšŸìˆ˜ í‘œì‹œ)
                updateAllButtons();
                document.getElementById('btnRestart').addEventListener('click', () => {
                    popup.classList.remove('show'); newGame();
                });
                document.getElementById('btnBack').addEventListener('click', () => { popup.classList.remove('show'); });
                document.getElementById('btnViewBest').addEventListener('click', () => {
                    if (bestGameState) { renderMiniPopup(bestGameState, playerId, bestScore); }
                    else alert("ì•„ì§ ìµœê³  ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.");
                });
                document.getElementById('btnNew').addEventListener('click', () => { newGame(); });
                document.getElementById('btnUndo').addEventListener('click', undoMove);
                document.getElementById('btnResetId').addEventListener('click', () => { askPlayerId(true); });

                // ğŸ”¥ ì—¬ê¸° ì¶”ê°€
                document.getElementById('btnRankManual').addEventListener('click', () => {
                    popup.classList.add('show');  // íŒì—…ì„ ê°•ì œë¡œ ë³´ì—¬ì£¼ê¸°
                    rankingsEl.innerHTML = "<div style='padding:10px'>ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ì¤‘...</div>";
                    loadRanking();
                });

                // ë¸”ë¡ ì œê±° ëª¨ë“œ ë²„íŠ¼ ì„¤ì •
                document.getElementById('btnBlockRemoval').addEventListener('click', toggleBlockRemovalMode);
                
                // ëª¬ìŠ¤í„° ì†Œí™˜ ë²„íŠ¼ ì„¤ì •
                document.getElementById('btnSpawnMonster').addEventListener('click', function() {
                    // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘ì—ëŠ” ì…ë ¥ ë¬´ì‹œ
                    if (isAnimating) {
                        info("ì• ë‹ˆë©”ì´ì…˜ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.", "warn");
                        return;
                    }
                    
                    // í˜„ì¬ ìƒíƒœ ì €ì¥
                    saveSnapshot();
                    
                    // ëª¬ìŠ¤í„° ì†Œí™˜
                    spawnMonsterOnly();
                });
                
                // ì¡°ì»¤ ì†Œí™˜ ë²„íŠ¼ ì„¤ì •
                document.getElementById('btnSpawnWildcard').addEventListener('click', function() {
                    // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘ì—ëŠ” ì…ë ¥ ë¬´ì‹œ
                    if (isAnimating) {
                        info("ì• ë‹ˆë©”ì´ì…˜ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.", "warn");
                        return;
                    }
                    
                    // í˜„ì¬ ìƒíƒœ ì €ì¥
                    saveSnapshot();
                    
                    // ì¡°ì»¤ ì†Œí™˜
                    spawnWildcardOnly();
                });
                
                // updateBlockRemovalButton í•¨ìˆ˜ëŠ” ì „ì—­ìœ¼ë¡œ ì˜®ê²¼ìŠµë‹ˆë‹¤
                
                // ë³´ìƒ ì˜µì…˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì´ˆê¸°í™”
                initRewardHandlers();
                
                // ë¸”ë¡ ì œê±° ëª¨ë“œ í† ê¸€ í•¨ìˆ˜
                function toggleBlockRemovalMode() {
                    // ë‚¨ì€ ì‚¬ìš© íšŸìˆ˜ê°€ ì—†ìœ¼ë©´ ëª¨ë“œ í™œì„±í™” ë¶ˆê°€
                    if (blockRemovalUsesLeft <= 0) {
                        info("ë¸”ë¡ ì œê±° ê¸°ëŠ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.", "err");
                        return;
                    }
                    
                    blockRemovalMode = !blockRemovalMode;
                    
                    if (blockRemovalMode) {
                        info("ë¸”ë¡ ì œê±° ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ˆë¡ìƒ‰ìœ¼ë¡œ í‘œì‹œëœ ì œê±° ê°€ëŠ¥í•œ ë¸”ë¡ì„ í´ë¦­í•˜ì„¸ìš”.");
                        
                        // ì„ íƒ ìƒíƒœ ì´ˆê¸°í™”
                        selected = null;
                        highlightSelection();
                        clearPossibleMoves();
                        
                        // ì œê±° ê°€ëŠ¥í•œ ë¸”ë¡ë“¤ì„ ì‹œê°ì ìœ¼ë¡œ í‘œì‹œ
                        showRemovableBlocks();
                        
                        // ì»¤ì„œ ë³€ê²½
                        document.body.style.cursor = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' width=\'32\' height=\'32\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%2346d3ff\' stroke-width=\'2\' stroke-linecap=\'round\' stroke-linejoin=\'round\'%3E%3Cline x1=\'18\' y1=\'6\' x2=\'6\' y2=\'18\'%3E%3C/line%3E%3Cline x1=\'6\' y1=\'6\' x2=\'18\' y2=\'18\'%3E%3C/line%3E%3C/svg%3E") 16 16, pointer';
                    } else {
                        info("ë¸”ë¡ ì œê±° ëª¨ë“œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.");
                        
                        // ë¸”ë¡ ì‹œê°í™” íš¨ê³¼ ì œê±°
                        clearRemovableBlocks();
                        document.body.style.cursor = '';
                    }
                    
                    updateBlockRemovalButton();
                }

            }

            // ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ í•¨ìˆ˜ë“¤
            function highlightPath(path) {
                if (!path || path.length < 2) return;
                
                // ì‹œì‘ì ê³¼ ëì ì„ ì œì™¸í•œ ì¤‘ê°„ ê²½ë¡œë§Œ í•˜ì´ë¼ì´íŠ¸
                for (let i = 1; i < path.length - 1; i++) {
                    const cell = board.children[path[i].r * COLS + path[i].c];
                    if (cell) {
                        cell.classList.add('path-highlight');
                    }
                }
            }

            function clearPathHighlight() {
                board.querySelectorAll('.path-highlight').forEach(el => {
                    el.classList.remove('path-highlight');
                });
            }

            /* ====== ì´ë™ ====== */
            function onTapCell() {
                            // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘ì—ëŠ” ì…ë ¥ ë¬´ì‹œ
                            if (isAnimating) return;
                            
                            const r = +this.dataset.r, c = +this.dataset.c;

                            // í•¨ìˆ˜ ì‹œì‘ ì‹œ, ì´ì „ í•˜ì´ë¼ì´íŠ¸ë¥¼ ëª¨ë‘ ì œê±°
                            clearPossibleMoves();
                            
                            // ë¸”ë¡ ì œê±° ëª¨ë“œì¸ ê²½ìš° ì „ìš© ë¡œì§ ì²˜ë¦¬
                            if (blockRemovalMode) {
                                // ë¸”ë¡ì´ ì•„ë‹Œ ê²½ìš° ê²½ê³ 
                                if (!isBlocked(r, c)) {
                                    info("ë¸”ë¡ ì œê±° ëª¨ë“œ: ì œê±°í•  ë¸”ë¡ì„ ì„ íƒí•˜ì„¸ìš”.", "warn");
                                    return;
                                }
                                
                                // ì œê±° ë¶ˆê°€ëŠ¥í•œ ë¸”ë¡ì¸ ê²½ìš° ê²½ê³ 
                                if (!isBlockRemovable(r, c)) {
                                    info("ì´ ë¸”ë¡ì„ ì œê±°í•˜ë©´ ê²Œì„ì´ ë¶ˆê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤. ë‹¤ë¥¸ ë¸”ë¡ì„ ì„ íƒí•˜ì„¸ìš”.", "err");
                                    return;
                                }
                                
                                // ì œê±° ê°€ëŠ¥í•œ ë¸”ë¡ë§Œ ì œê±°
                                if (toggleBlockedTile(r, c, true)) {
                                    // ë¸”ë¡ ì œê±° ì„±ê³µ
                                    return;
                                }
                                return;
                            }
                            
                            // ì¼ë°˜ ëª¨ë“œì—ì„œëŠ” ë¸”ë¡ íƒ€ì¼ ìƒì„±/ì œê±° ë¶ˆê°€ëŠ¥í•˜ë„ë¡ ìˆ˜ì •
                            // ë¸”ë¡ ì œê±°ëŠ” ë¸”ë¡ ì œê±° ëª¨ë“œì—ì„œë§Œ ê°€ëŠ¥í•˜ë„ë¡ í•¨
                            if (selected === null && (isEmpty(r, c) || isBlocked(r, c))) {
                                // toggleBlockedTile ê¸°ëŠ¥ ë¹„í™œì„±í™” (ë¸”ë¡ ì œê±° ëª¨ë“œì—ì„œë§Œ ê°€ëŠ¥)
                                if (isBlocked(r, c)) {
                                    info("ë¸”ë¡ì„ ì œê±°í•˜ë ¤ë©´ ë¸”ë¡ ì œê±° ëª¨ë“œë¥¼ í™œì„±í™”í•˜ì„¸ìš”.", "warn");
                                }
                                return;
                            }

                            if (isTile(r, c)) {
                                selected = { r, c };
                                highlightSelection();
                                
                                // ì„ íƒëœ ë¸”ë¡ ê¸°ì¤€ìœ¼ë¡œ ì´ë™ ê°€ëŠ¥í•œ ìœ„ì¹˜ë¥¼ í‘œì‹œ
                                showPossibleMoves(r, c);
                                
                                // ğŸµ í´ë¦­ìŒ
                                sounds.click.currentTime = 0;
                                playSoundSafely(sounds.click);
                                return;
                            }
                            if (isEmpty(r, c) && selected) {
                                const from = { ...selected }, to = { r, c }, val = grid[from.r][from.c];
                                
                                // í–¥ìƒëœ ì´ë™ ê²€ì¦ í•¨ìˆ˜ ì‚¬ìš©
                                const validation = validateMergeMove(from, to, val);
                                
                                if (!validation.valid) {
                                    info(validation.reasons.join("\n"), "err"); 
                                    return;
                                }
                                
                                const path = findPathViaEmpties(from, to);
                                const gsize = validation.groupSize;
                                
                                // ì´ë™í•˜ê¸° ì „ í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥
                                saveSnapshot();

                    // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                    isAnimating = true;
                    
                    // ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ì´ë™
                    animateMoveTile(from, to, path, () => {
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ê²Œì„ ë¡œì§ ì²˜ë¦¬
                        if (gsize >= 3) {
                            // ğŸµ ë¨¸ì§€ ì‚¬ìš´ë“œ ì „ìš©
                            const mergeResult = resolveAutoMerges(to);
                            
                            // ë³‘í•© í›„ ë³´ìƒ ì¡°ê±´ í™•ì¸ ë° íŒì—… í‘œì‹œ
                            // if (shouldShowReward(mergeResult)) {
                            //     // ì•½ê°„ì˜ ì§€ì—° í›„ íŒì—… í‘œì‹œ (ì• ë‹ˆë©”ì´ì…˜ì´ ì™„ë£Œëœ í›„)
                            //     setTimeout(() => {
                            //         showRewardPopup();
                            //     }, 700); // ë³‘í•© ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì ë‹¹í•œ ì‹œê°„ ì§€ì—°
                            // }
                        } else {
                            // ğŸµ ì´ë™ ì‚¬ìš´ë“œ (ë¨¸ì§€ ì•„ë‹ ë•Œë§Œ)
                            sounds.move.currentTime = 0;
                            playSoundSafely(sounds.move);
                        }

                        turn++; untilSpawn--; blockSpawnTurn--;
                        if (untilSpawn === 0) { spawnBatch(); untilSpawn = SPAWN_EVERY; }
                        if (blockSpawnTurn === 0) { spawnBlock(); blockSpawnTurn = BLOCK_SPAWN_INTERVAL; }
                        // saveSnapshot í˜¸ì¶œì€ ëª¨ë“  ì²˜ë¦¬ê°€ ì™„ë£Œëœ í›„ í•œ ë²ˆë§Œ ìˆ˜í–‰ë¨
                        elTurn.textContent = String(turn);
                        elNext.textContent = String(untilSpawn);
                        elBlock.textContent = String(blockSpawnTurn);
                        selected = null; 
                        highlightSelection();
                        clearPossibleMoves();
                        
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ
                        isAnimating = false;
                        
                        // ì´ë™ ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆì§€ë§Œ ì´ë™ ì „ ìƒíƒœëŠ” ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŒ
                        
                        checkGameOverSoon();
                    });
                }
            }

            // ê²½ë¡œë¥¼ ë”°ë¼ ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ ì´ë™í•˜ëŠ” í•¨ìˆ˜ (ìƒˆë¡œìš´ ë°©ì‹)
            function animateMoveTile(from, to, path, callback) {
                console.log('ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘:', from, 'â†’', to, 'ê²½ë¡œ ê¸¸ì´:', path ? path.length : 0);
                const v = grid[from.r][from.c];
                const fromCell = board.children[from.r * COLS + from.c];
                const fromTile = fromCell.querySelector('.tile');
                
                if (!fromTile || !path || path.length < 2) {
                    moveTileInstant(from, to);
                    if (callback) callback();
                    return;
                }

                // íƒ€ì¼ ë³µì‚¬ë³¸ ìƒì„±
                const animatingTile = fromTile.cloneNode(true);
                animatingTile.classList.add('moving');
                
                // ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸
                highlightPath(path);
                
                // ê·¸ë¦¬ë“œ ìƒíƒœ ì—…ë°ì´íŠ¸
                grid[from.r][from.c] = 0;
                grid[to.r][to.c] = v;
                
                // ì›ë³¸ íƒ€ì¼ì„ ì¦‰ì‹œ ìˆ¨ê¸°ê³  ë¹ˆ ì…€ë¡œ í‘œì‹œ
                fromTile.style.visibility = 'hidden';
                drawCell(from.r, from.c);
                
                // ë³´ë“œì— ì• ë‹ˆë©”ì´ì…˜ íƒ€ì¼ ì¶”ê°€
                board.appendChild(animatingTile);
                
                // ì‹œì‘ ìœ„ì¹˜ ì„¤ì •
                setTilePosition(animatingTile, path[0]);
                
                // ê²½ë¡œë¥¼ ë”°ë¼ ì´ë™
                animateStepByStep(animatingTile, path, 0, () => {
                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ
                    animatingTile.remove();
                    drawCell(to.r, to.c);
                    clearPathHighlight();
                    
                    const finalTile = board.children[to.r * COLS + to.c].querySelector('.tile');
                    if (finalTile) { 
                        finalTile.classList.add('bump'); 
                        setTimeout(() => finalTile.classList.remove('bump'), 200); 
                    }
                    
                    if (callback) callback();
                });
            }

            // íƒ€ì¼ì„ íŠ¹ì • ê·¸ë¦¬ë“œ ìœ„ì¹˜ì— ë°°ì¹˜ (transform ë°©ì‹)
            function setTilePosition(tile, gridPos) {
                const targetCell = board.children[gridPos.r * COLS + gridPos.c];
                const rect = targetCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                
                tile.style.position = 'absolute';
                tile.style.left = (rect.left - boardRect.left) + 'px';
                tile.style.top = (rect.top - boardRect.top) + 'px';
                tile.style.width = targetCell.offsetWidth + 'px';
                tile.style.height = targetCell.offsetHeight + 'px';
                tile.style.transition = 'none';
            }

            // ë‹¨ê³„ë³„ ì´ë™ ì• ë‹ˆë©”ì´ì…˜ (transform ë°©ì‹)
            function animateStepByStep(tile, path, currentStep, callback) {
                if (currentStep >= path.length - 1) {
                    if (callback) callback();
                    return;
                }

                const nextPos = path[currentStep + 1];
                const targetCell = board.children[nextPos.r * COLS + nextPos.c];
                const rect = targetCell.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();
                
                // CSS transition ì„¤ì • (ì•„ì£¼ ì¡°ê¸ˆ ë” ë¹ ë¥´ê²Œ)
                tile.style.transition = 'left 100ms ease-out, top 100ms ease-out';
                
                // ë‹¤ìŒ ìœ„ì¹˜ë¡œ ì´ë™
                tile.style.left = (rect.left - boardRect.left) + 'px';
                tile.style.top = (rect.top - boardRect.top) + 'px';
                
                // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™ (ì•„ì£¼ ì¡°ê¸ˆ ë” ë¹ ë¥´ê²Œ)
                setTimeout(() => {
                    animateStepByStep(tile, path, currentStep + 1, callback);
                }, 100);
            }

            // ì¦‰ì‹œ ì´ë™ (ê¸°ì¡´ ë¡œì§)
            function moveTileInstant(from, to) {
                const v = grid[from.r][from.c];
                grid[from.r][from.c] = 0; grid[to.r][to.c] = v;
                
                // ì•„ì´í…œ ì •ë³´ ì´ë™
                moveItem(from.r, from.c, to.r, to.c);
                
                drawCell(from.r, from.c); drawCell(to.r, to.c);
                const tCell = board.children[to.r * COLS + to.c].querySelector('.tile');
                if (tCell) { tCell.classList.add('bump'); setTimeout(() => tCell.classList.remove('bump'), 200); }
            }

            function moveTile(from, to) {
                // ê¸°ë³¸ì ìœ¼ë¡œ ì¦‰ì‹œ ì´ë™ (í•˜ìœ„ í˜¸í™˜ì„±)
                moveTileInstant(from, to);
            }

            /* ====== ê²½ë¡œ íƒìƒ‰ ====== */
            function findPathViaEmpties(from, to) {
                const q = [from], prev = Array.from({ length: ROWS }, () => Array(COLS).fill(null)), vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                vis[from.r][from.c] = true;
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                while (q.length) {
                    const cur = q.shift();
                    for (const [dr, dc] of dirs) {
                        const nr = cur.r + dr, nc = cur.c + dc;
                        if (!inBounds(nr, nc) || vis[nr][nc]) continue;
                        if (nr === to.r && nc === to.c) { if (!isEmpty(nr, nc)) continue; }
                        else if (isBlocked(nr, nc) || isTile(nr, nc)) continue;
                        vis[nr][nc] = true; prev[nr][nc] = cur;
                        if (nr === to.r && nc === to.c) {
                            const path = []; let x = { r: nr, c: nc };
                            while (x) { path.push(x); x = prev[x.r][x.c]; }
                            path.reverse(); return path;
                        }
                        q.push({ r: nr, c: nc });
                    }
                }
                return null;
            }
            function destAdjacentSame(to, val) {
                return [[1, 0], [-1, 0], [0, 1], [0, -1]].
                    some(([dr, dc]) => {
                        const nr = to.r + dr, nc = to.c + dc;
                        if (!inBounds(nr, nc)) return false;
                        
                        const neighborValue = grid[nr][nc];
                        
                        // ë¹ˆ ì…€ì´ë‚˜ ë¸”ë¡ëœ ì…€ì€ ì œì™¸
                        if (neighborValue === 0 || neighborValue === -1) return false;
                        
                        // ì™€ì¼ë“œì¹´ë“œ ë¡œì§: 
                        // 1. ì¸ì ‘ íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì´ê±°ë‚˜
                        // 2. í˜„ì¬ íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì´ê±°ë‚˜
                        // 3. ê°™ì€ ê°’ì´ë©´ ë§¤ì¹˜ ê°€ëŠ¥
                        return neighborValue === WILDCARD_TILE || val === WILDCARD_TILE || neighborValue === val;
                    });
            }
            // í–¥ìƒëœ floodSame í•¨ìˆ˜: ë³€ìˆ˜ ê·¸ë£¹ í¬ê¸° ì§€ì›, ì™€ì¼ë“œì¹´ë“œ ê°’ ì œí•œ(9 ì´í•˜), ì¼ê´€ëœ ìˆœì„œ ë³´ì¥
            function floodSame(sr, sc, val, g = grid, maxSize = 3) { // maxSize ë§¤ê°œë³€ìˆ˜ ì¶”ê°€ (ê¸°ë³¸ê°’ 3)
                // BFS ë°©ì‹ìœ¼ë¡œ êµ¬í˜„í•˜ì—¬ ì¼ê´€ëœ ìˆœì„œ ë³´ì¥
                const vis = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                const q = [{ r: sr, c: sc }];
                const out = [];
                let wildcardCount = 0;
                let firstNonWildcardValue = null; // ì¶”ê°€: ì²˜ìŒ ë°œê²¬ëœ ì¼ë°˜ íƒ€ì¼ ê°’ ì¶”ì 
                
                // ì‹œì‘ íƒ€ì¼ ê°’ í™•ì¸
                const startingValue = g[sr][sc];
                const startIsWildcard = startingValue === WILDCARD_TILE;
                
                // ì²« íƒ€ì¼ì´ ì¼ë°˜ íƒ€ì¼ì´ë©´ í•´ë‹¹ ê°’ ì €ì¥
                if (!startIsWildcard) {
                    firstNonWildcardValue = startingValue;
                }
                
                // ì²« íƒ€ì¼ ì²˜ë¦¬
                vis[sr][sc] = true;
                
                // BFS ë¡œì§
                while (q.length > 0) {
                    const { r, c } = q.shift();
                    const tileValue = g[r][c];
                    
                    // íƒ€ì¼ ì •ë³´ë¥¼ ì €ì¥í•˜ê³  ì™€ì¼ë“œì¹´ë“œ ê°œìˆ˜ í™•ì¸
                    out.push({ r, c, value: tileValue });
                    if (tileValue === WILDCARD_TILE) {
                        wildcardCount++;
                    } else if (firstNonWildcardValue === null) {
                        // ì²« ë²ˆì§¸ ì¼ë°˜ íƒ€ì¼ ê°’ ì €ì¥
                        firstNonWildcardValue = tileValue;
                    }
                    
                    // ìµœëŒ€ ê·¸ë£¹ í¬ê¸° ì œí•œ (3ê°œ ì´ìƒì€ ì°¾ì§€ ì•ŠìŒ)
                    if (out.length >= maxSize) {
                        break; // ìµœëŒ€ í¬ê¸°ì— ë„ë‹¬í•˜ë©´ ë°˜ë³µë¬¸ ì¢…ë£Œ
                    }
                    
                    // 4ë°©í–¥ ì²´í¬ (ìƒí•˜ì¢Œìš°)
                    for (const [dr, dc] of [[1, 0], [0, 1], [-1, 0], [0, -1]]) {
                        const nr = r + dr, nc = c + dc;
                        
                        // ìœ íš¨ì„± ê²€ì‚¬ + ë°©ë¬¸ ì—¬ë¶€ í™•ì¸
                        if (!inBounds(nr, nc) || vis[nr][nc]) continue;
                        
                        const neighborTileValue = g[nr][nc];
                        const neighborIsWildcard = neighborTileValue === WILDCARD_TILE;
                        const neighborIsValidTile = neighborTileValue > 0 || neighborIsWildcard;
                        
                        // ì´ì›ƒ íƒ€ì¼ì´ ìœ íš¨í•œ íƒ€ì¼ì´ ì•„ë‹ˆë©´ ê±´ë„ˆëœ€
                        if (!neighborIsValidTile) continue;
                        
                        // ê°œì„ ëœ ì‹œë‚˜ë¦¬ì˜¤ ì²´í¬
                        // 1. ì¼ë°˜ íƒ€ì¼ì´ ê°™ì€ ê°’ì¸ ê²½ìš° ë§¤ì¹˜
                        // 2. ì™€ì¼ë“œì¹´ë“œ ë§¤ì¹­ ê·œì¹™ (ê°™ì€ ê°’ì˜ íƒ€ì¼ë“¤ê³¼ë§Œ ë§¤ì¹˜):
                        //    - ëª¨ë“  íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš° (ê·¸ë£¹ì´ ì™€ì¼ë“œì¹´ë“œë¡œë§Œ êµ¬ì„±)
                        //    - ì´ì›ƒ íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì´ê³ , í˜„ì¬ íƒ€ì¼ì´ ì²« ë¹„ì™€ì¼ë“œì¹´ë“œ ê°’ê³¼ ê°™ì€ ê²½ìš°
                        //    - í˜„ì¬ íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì´ê³ , ì´ì›ƒ íƒ€ì¼ì´ ì²« ë¹„ì™€ì¼ë“œì¹´ë“œ ê°’ê³¼ ê°™ì€ ê²½ìš°
                        
                        const currentTileIsWildcard = tileValue === WILDCARD_TILE;
                        const normalMatch = neighborTileValue === val;
                        
                        // ì™€ì¼ë“œì¹´ë“œ ë§¤ì¹­ ë¡œì§
                        // ì™€ì¼ë“œì¹´ë“œëŠ” 9 ì´í•˜ì˜ íƒ€ì¼ì—ë§Œ ì‘ë™í•˜ë„ë¡ ì œí•œ
                        let wildcardMatch = false;
                        
                        // ëª¨ë“  íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš°
                        if (firstNonWildcardValue === null) {
                            wildcardMatch = true;
                        }
                        // ì´ì›ƒì´ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš°
                        else if (neighborIsWildcard && !currentTileIsWildcard) {
                            // í˜„ì¬ íƒ€ì¼ì´ ì²« ë¹„ì™€ì¼ë“œì¹´ë“œ ê°’ê³¼ ê°™ê³ , ê°’ì´ 9 ì´í•˜ì¸ ê²½ìš°ë§Œ ë§¤ì¹­
                            wildcardMatch = tileValue === firstNonWildcardValue && firstNonWildcardValue <= 9;
                        }
                        // í˜„ì¬ê°€ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš°
                        else if (currentTileIsWildcard && !neighborIsWildcard) {
                            // ì´ì›ƒ íƒ€ì¼ì´ ì²« ë¹„ì™€ì¼ë“œì¹´ë“œ ê°’ê³¼ ê°™ê³ , ê°’ì´ 9 ì´í•˜ì¸ ê²½ìš°ë§Œ ë§¤ì¹­
                            wildcardMatch = neighborTileValue === firstNonWildcardValue && firstNonWildcardValue <= 9;
                        }
                        // ë‘˜ ë‹¤ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš°
                        else if (currentTileIsWildcard && neighborIsWildcard) {
                            wildcardMatch = true;
                        }
                        
                        if (normalMatch || wildcardMatch) {
                            vis[nr][nc] = true;
                            q.push({ r: nr, c: nc });
                        }
                    }
                }
                
                // ê²°ê³¼ì— ê·¸ë£¹ ë©”íƒ€ë°ì´í„° ì¶”ê°€
                out.size = out.length;
                out.wildcardCount = wildcardCount;
                out.value = val;
                out.pivot = out.length > 0 ? { r: out[0].r, c: out[0].c } : null;
                
                return out;
            }
            function groupSizeIfMoved(from, to, val) {
                const tmp = cloneGrid(grid);
                tmp[from.r][from.c] = 0; tmp[to.r][to.c] = val;
                // ì§€ì •ëœ ìœ„ì¹˜ì— íƒ€ì¼ì„ ì´ë™í•œ í›„ ê·¸ë£¹ í¬ê¸° ê²€ì‚¬
                // ê·¸ë£¹ í¬ê¸° 3ê°œë¡œ ì œí•œí•˜ì—¬ ì¡°íšŒ
                return floodSame(to.r, to.c, val, tmp, 3).length;
            }
            /* ====== ë³´ë“œ ìƒì„± & ìƒˆê²Œì„ ====== */
            function makeGrid() { return Array.from({ length: ROWS }, () => Array(COLS).fill(0)); }

            function newGame() {
                popupTitle.textContent = "ê²Œì„ ì˜¤ë²„";
                grid = makeGrid();
                clearItems(); // ì•„ì´í…œ ì´ˆê¸°í™”
                placeRandomBlocks(-1, BLOCK_MIN + ((Math.random() * (BLOCK_MAX - BLOCK_MIN + 1)) | 0));
                placeRandomTilesAvoidingTriples(INIT_TILES, 400);
                
                // ì´ˆê¸° íƒ€ì¼ì—ëŠ” ì•„ì´í…œì„ ë¶€ì—¬í•˜ì§€ ì•ŠìŒ
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (grid[r][c] > 0 || grid[r][c] === WILDCARD_TILE) {
                            setItem(r, c, false);
                        }
                    }
                }
                
                renderAll(true);
                requestAnimationFrame(() => { 
                    const mergeResult = resolveAutoMerges(); 
                    /* saveSnapshot() ì œê±° - ê²Œì„ ì´ˆê¸°í™” ì‹œì—ëŠ” ìŠ¤ëƒ…ìƒ·ì„ ì €ì¥í•˜ì§€ ì•ŠìŒ */ 
                    
                    // ê²Œì„ ì‹œì‘ ì‹œì—ë„ ë³´ìƒ íŒì—… í™•ì¸
                    if (shouldShowReward(mergeResult)) {
                        setTimeout(() => {
                            showRewardPopup();
                        }, 700);
                    }
                });
                turn = 0; untilSpawn = SPAWN_EVERY; spawnCount = 0; blockSpawnTurn = BLOCK_SPAWN_INTERVAL; selected = null; gameOverShown = false;
                blockRemovalMode = false; blockRemovalUsesLeft = 3; // ë¸”ë¡ ì œê±° ëª¨ë“œ ë° íšŸìˆ˜ ì´ˆê¸°í™”
                history = []; // íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
                
                // ê¸°ëŠ¥ ì‚¬ìš© íšŸìˆ˜ ì´ˆê¸°í™”
                undoUsesLeft = 3;
                monsterSpawnUsesLeft = 5;
                wildcardSpawnUsesLeft = 2;
                
                // ëª¨ë“  ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì‚¬ìš© íšŸìˆ˜ í‘œì‹œ)
                updateAllButtons();
                elTurn.textContent = '0'; elNext.textContent = String(SPAWN_EVERY); elBlock.textContent = String(BLOCK_SPAWN_INTERVAL);
                // ì´ˆê¸° í™”ë©´ì—ì„œ ë¸”ë¡ ìƒì„± í„´ í‘œì‹œ
                updateBlockRemovalButton(); // ë¸”ë¡ ì œê±° ë²„íŠ¼ ì—…ë°ì´íŠ¸
                popup.classList.remove('show');
                checkGameOverSoon();
            }

            /* ====== ì†Œí™˜ ====== */
            function placeRandomBlocks(v, count) {
                const E = listEmpty(); shuffle(E);
                for (let i = 0; i < count && i < E.length; i++) grid[E[i].r][E[i].c] = v;
            }
            function placeRandomTilesAvoidingTriples(count, maxTry = 200) {
                let placed = 0, tries = 0;
                while (placed < count && tries < maxTry) {
                    const E = listEmpty(); if (!E.length) break;
                    const p = E[(Math.random() * E.length) | 0], v = randomValue();
                    grid[p.r][p.c] = v;
                    if (findAnyGroupGE3()) { 
                        grid[p.r][p.c] = 0; 
                        setItem(p.r, p.c, false); // ì œê±°í•œ íƒ€ì¼ì€ ì•„ì´í…œ ì œê±°
                    } else { 
                        placed++; 
                        setItem(p.r, p.c, false); // ê²Œì„ ì´ˆê¸° íƒ€ì¼ì—ëŠ” ì•„ì´í…œì„ ë¶€ì—¬í•˜ì§€ ì•ŠìŒ
                    }
                    tries++;
                }
                if (placed < count) placeRandomTiles(count - placed);
            }
            function placeRandomTiles(count) {
                const E = listEmpty(); shuffle(E);
                for (let i = 0; i < count && i < E.length; i++) {
                    grid[E[i].r][E[i].c] = randomValue();
                    setItem(E[i].r, E[i].c, false); // ê²Œì„ ì´ˆê¸° íƒ€ì¼ì—ëŠ” ì•„ì´í…œì„ ë¶€ì—¬í•˜ì§€ ì•ŠìŒ
                }
            }
            function spawnBatch() {
                spawnCount++;
                if (spawnCount % MEGA_INTERVAL === 0) {
                    info("ğŸŒŸ ëŒ€ì†Œí™˜! ë¸”ë¡ 2ë°° ì†Œí™˜!");
                    for (let i = 0; i < SPAWN_BATCH * 2; i++) spawnOne();
                } else {
                    for (let i = 0; i < SPAWN_BATCH; i++) spawnOne();
                }
                elMega.textContent = String(MEGA_INTERVAL - (spawnCount % MEGA_INTERVAL || MEGA_INTERVAL));
            }
            
            // ë°©í•´ ë¸”ë¡ ìƒì„± í•¨ìˆ˜
            function spawnBlock() {
                info("âš ï¸ ê²½ê³ ! ë°©í•´ ë¸”ë¡ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤!", "warn");
                
                // ë¸”ë¡ ìƒì„±ì„ ìœ„í•œ ë¹ˆ ì…€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const emptyCells = listEmpty();
                if (!emptyCells.length) return false; // ë¹ˆ ì…€ì´ ì—†ìœ¼ë©´ ìƒì„± ì‹¤íŒ¨
                
                // ìœ íš¨í•œ ìƒì„± ìœ„ì¹˜ ì°¾ê¸° (ê²Œì„ì´ ë¶ˆê°€ëŠ¥í•´ì§€ëŠ” ìœ„ì¹˜ì—ëŠ” ìƒì„±í•˜ì§€ ì•ŠìŒ)
                shuffle(emptyCells);
                
                for (const cell of emptyCells) {
                    // ì´ ìœ„ì¹˜ì— ë¸”ë¡ì„ ìƒì„±í•´ë„ ê²Œì„ì´ ê°€ëŠ¥í•œì§€ í™•ì¸
                    if (canCreateBlockedTile(cell.r, cell.c)) {
                        // ë¸”ë¡ ìƒì„±
                        grid[cell.r][cell.c] = -1;
                        drawCell(cell.r, cell.c, { spawn: true });
                        
                        // íš¨ê³¼ìŒ ì¬ìƒ
                        sounds.block.currentTime = 0;
                        playSoundSafely(sounds.block);
                        
                        // íŒŒí‹°í´ íš¨ê³¼ í‘œì‹œ
                        const cellElement = board.children[cell.r * COLS + cell.c];
                        const rect = cellElement.getBoundingClientRect();
                        createParticles(rect.left + rect.width/2, rect.top + rect.height/2, 15, 1.2);
                        
                        return true;
                    }
                }
                
                // ì í•©í•œ ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•¨ - ì´ë²ˆì—ëŠ” ë¸”ë¡ ìƒì„± ê±´ë„ˆëœ€ê³  ì•Œë¦¼
                info("ì´ë²ˆ í„´ì—ëŠ” ë°©í•´ ë¸”ë¡ ìƒì„±ì„ ê±´ë„ˆëœë‹ˆë‹¤.", "warn");
                return false;
            }
            function spawnOne() {
                const E = listEmpty(); if (!E.length) return false;
                const p = E[(Math.random() * E.length) | 0];
                grid[p.r][p.c] = randomValue();
                
                // ìì—° ì†Œí™˜ëœ ëª¬ìŠ¤í„°ì—ëŠ” ì•„ì´í…œ ë¶€ì—¬
                setItem(p.r, p.c, true);
                
                drawCell(p.r, p.c, { spawn: true });
                const mergeResult = resolveAutoMerges();
                
                // ë³‘í•© í›„ ë³´ìƒ ì¡°ê±´ í™•ì¸ ë° íŒì—… í‘œì‹œ
                if (shouldShowReward(mergeResult)) {
                    setTimeout(() => {
                        showRewardPopup();
                    }, 700);
                }
                return true;
            }
            
            // ëª¬ìŠ¤í„°ë§Œ ëœë¤ ì†Œí™˜í•˜ëŠ” í•¨ìˆ˜ (ì¡°ì»¤ ì œì™¸)
            function spawnMonsterOnly() {
                // ë‚¨ì€ íšŸìˆ˜ í™•ì¸
                if (monsterSpawnUsesLeft <= 0) {
                    info("ëª¬ìŠ¤í„° ì†Œí™˜ ê¸°ëŠ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.", "err");
                    return false;
                }
                
                const E = listEmpty(); 
                if (!E.length) {
                    info("ë” ì´ìƒ ëª¬ìŠ¤í„°ë¥¼ ì†Œí™˜í•  ê³µê°„ì´ ì—†ìŠµë‹ˆë‹¤.", "err");
                    return false;
                }
                
                const p = E[(Math.random() * E.length) | 0];
                grid[p.r][p.c] = randomValueNoWildcard();
                
                // ê¸°ëŠ¥ìœ¼ë¡œ ì†Œí™˜ëœ ëª¬ìŠ¤í„°ëŠ” ì•„ì´í…œì„ ê°€ì§€ì§€ ì•ŠìŒ
                setItem(p.r, p.c, false);
                
                drawCell(p.r, p.c, { spawn: true });
                
                // ì†Œí™˜ íš¨ê³¼ìŒ ì¬ìƒ
                sounds.move.currentTime = 0;
                playSoundSafely(sounds.move);
                
                // íŒŒí‹°í´ íš¨ê³¼ í‘œì‹œ
                const cellElement = board.children[p.r * COLS + p.c];
                const rect = cellElement.getBoundingClientRect();
                createParticles(rect.left + rect.width/2, rect.top + rect.height/2, 10, 1.0);
                
                // ì‚¬ìš© íšŸìˆ˜ ì°¨ê° ë° ë²„íŠ¼ ì—…ë°ì´íŠ¸
                monsterSpawnUsesLeft--;
                updateMonsterSpawnButton();
                
                // ë³‘í•© ê°€ëŠ¥í•œ ê·¸ë£¹ì´ ìˆëŠ”ì§€ í™•ì¸
                const mergeResult = resolveAutoMerges();
                
                // ë³‘í•© í›„ ë³´ìƒ ì¡°ê±´ í™•ì¸ ë° íŒì—… í‘œì‹œ
                if (shouldShowReward(mergeResult)) {
                    setTimeout(() => {
                        showRewardPopup();
                    }, 700);
                }
                
                // ê²Œì„ ì˜¤ë²„ ì²´í¬
                checkGameOverSoon();
                
                return true;
            }
            
            // ì¡°ì»¤(ì™€ì¼ë“œì¹´ë“œ)ë§Œ ì†Œí™˜í•˜ëŠ” í•¨ìˆ˜
            function spawnWildcardOnly() {
                // ë‚¨ì€ íšŸìˆ˜ í™•ì¸
                if (wildcardSpawnUsesLeft <= 0) {
                    info("ì¡°ì»¤ ì†Œí™˜ ê¸°ëŠ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.", "err");
                    return false;
                }
                
                const E = listEmpty();
                if (!E.length) {
                    info("ë” ì´ìƒ ì¡°ì»¤ë¥¼ ì†Œí™˜í•  ê³µê°„ì´ ì—†ìŠµë‹ˆë‹¤.", "err");
                    return false;
                }
                
                const p = E[(Math.random() * E.length) | 0];
                grid[p.r][p.c] = WILDCARD_TILE; // ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ ê°’ ì„¤ì •
                
                // ê¸°ëŠ¥ìœ¼ë¡œ ì†Œí™˜ëœ ì™€ì¼ë“œì¹´ë“œëŠ” ì•„ì´í…œì„ ê°€ì§€ì§€ ì•ŠìŒ
                setItem(p.r, p.c, false);
                
                drawCell(p.r, p.c, { spawn: true });
                
                // íŠ¹ë³„ íš¨ê³¼ìŒ ì¬ìƒ (ë©”ê°€ ë¨¸ì§€ íš¨ê³¼ìŒ ì‚¬ìš©)
                sounds.special.megaMerge.currentTime = 0;
                playSoundSafely(sounds.special.megaMerge);
                
                // í™”ë ¤í•œ íŒŒí‹°í´ íš¨ê³¼ í‘œì‹œ
                const cellElement = board.children[p.r * COLS + p.c];
                const rect = cellElement.getBoundingClientRect();
                createParticles(rect.left + rect.width/2, rect.top + rect.height/2, 20, 1.5);
                
                // í™”ë©´ ë²ˆì‹¬ íš¨ê³¼
                const flash = document.createElement('div');
                flash.className = 'screen-flash';
                document.body.appendChild(flash);
                setTimeout(() => flash.remove(), 300);
                
                // ì‚¬ìš© íšŸìˆ˜ ì°¨ê° ë° ë²„íŠ¼ ì—…ë°ì´íŠ¸
                wildcardSpawnUsesLeft--;
                updateWildcardSpawnButton();
                
                // ë³‘í•© ê°€ëŠ¥í•œ ê·¸ë£¹ì´ ìˆëŠ”ì§€ í™•ì¸
                const mergeResult = resolveAutoMerges();
                
                // ë³‘í•© í›„ ë³´ìƒ ì¡°ê±´ í™•ì¸ ë° íŒì—… í‘œì‹œ
                if (shouldShowReward(mergeResult)) {
                    setTimeout(() => {
                        showRewardPopup();
                    }, 700);
                }
                
                // ê²Œì„ ì˜¤ë²„ ì²´í¬
                checkGameOverSoon();
                
                info("âœ¨ ì¡°ì»¤ ëª¬ìŠ¤í„°ê°€ ì†Œí™˜ë˜ì—ˆìŠµë‹ˆë‹¤!");
                
                return true;
            }

            /* ====== ë¨¸ì§€ ====== */
            // ëª¨ë“  ë³‘í•© ê°€ëŠ¥í•œ ê·¸ë£¹ì„ ì°¾ëŠ” í•¨ìˆ˜
            function findMergeGroups(g = grid, minGroupSize = 3) {
                const seen = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                const mergeGroups = [];
                
                // ì™€ì¼ë“œì¹´ë“œ ì²˜ë¦¬ë¥¼ ìœ„í•´ ìš°ì„  ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ì„ ë¨¼ì € ì°¾ëŠ”ë‹¤
                const wildcardPositions = [];
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (g[r][c] === WILDCARD_TILE) {
                            wildcardPositions.push({r, c});
                        }
                    }
                }
                
                // ì™€ì¼ë“œì¹´ë“œê°€ ìˆìœ¼ë©´ ë¨¼ì € ì²˜ë¦¬
                for (const wildPos of wildcardPositions) {
                    if (seen[wildPos.r][wildPos.c]) continue;
                    
                    // ì™€ì¼ë“œì¹´ë“œ ê¸°ì¤€ìœ¼ë¡œ ê·¸ë£¹ ì°¾ê¸° - ìµœëŒ€ í¬ê¸° ì œí•œ ì—†ì´ íƒìƒ‰
                    const group = floodSame(wildPos.r, wildPos.c, WILDCARD_TILE, g, Infinity);
                    
                    // ê·¸ë£¹ì˜ ëª¨ë“  íƒ€ì¼ì„ ë°©ë¬¸ ì²˜ë¦¬
                    for (const p of group) {
                        seen[p.r][p.c] = true;
                    }
                    
                    // ìµœì†Œ ê·¸ë£¹ í¬ê¸° ì´ìƒì¸ ê²½ìš°ë§Œ ì €ì¥
                    if (group.length >= minGroupSize) {
                        mergeGroups.push({
                            tiles: group,
                            value: WILDCARD_TILE,
                            wildcardCount: group.wildcardCount || 0,
                            size: group.length,
                            pivot: group.pivot || group[0],
                            isWildcardGroup: true
                        });
                    }
                }
                
                // ë‚˜ë¨¸ì§€ ì¼ë°˜ íƒ€ì¼ ì²˜ë¦¬
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const v = g[r][c]; 
                        
                        // ë¹ˆ ì…€ì´ë‚˜ ì´ë¯¸ í™•ì¸í•œ ì…€ì€ ê±´ë„ˆë›°ê¸°
                        if ((v <= 0 && v !== WILDCARD_TILE) || seen[r][c]) continue;
                        
                        // í˜„ì¬ ì…€ì—ì„œ ê°™ì€ ê°’ ë˜ëŠ” ì™€ì¼ë“œì¹´ë“œë¡œ ì—°ê²°ëœ ê·¸ë£¹ ì°¾ê¸°
                        const group = floodSame(r, c, v, g);
                        
                        // ê·¸ë£¹ì˜ ëª¨ë“  íƒ€ì¼ì„ ë°©ë¬¸ ì²˜ë¦¬
                        for (const p of group) {
                            seen[p.r][p.c] = true;
                        }
                        
                        // ìµœì†Œ ê·¸ë£¹ í¬ê¸° ì´ìƒì¸ ê²½ìš°ë§Œ ì €ì¥
                        if (group.length >= minGroupSize) {
                            // ê·¸ë£¹ ì •ë³´ ì •ë¦¬
                            mergeGroups.push({
                                tiles: group,
                                value: v,
                                wildcardCount: group.wildcardCount || 0,
                                size: group.length,
                                pivot: group.pivot || group[0],
                                isWildcardGroup: false
                            });
                        }
                    }
                }
                
                // ê·¸ë£¹ì„ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì •ë ¬
                mergeGroups.sort((a, b) => {
                    // ì™€ì¼ë“œì¹´ë“œê°€ í¬í•¨ëœ ê·¸ë£¹ ìš°ì„ 
                    if (a.wildcardCount > 0 && b.wildcardCount === 0) return -1;
                    if (a.wildcardCount === 0 && b.wildcardCount > 0) return 1;
                    
                    // ì™€ì¼ë“œì¹´ë“œ ìˆ˜ê°€ ê°™ìœ¼ë©´ ê·¸ë£¹ í¬ê¸°ê°€ í° ê²ƒ ìš°ì„ 
                    if (a.wildcardCount === b.wildcardCount) {
                        if (a.size !== b.size) return b.size - a.size;
                    }
                    
                    // ê·¸ ì™¸ì—ëŠ” ê°’ì´ í° ê²ƒ ìš°ì„ 
                    return b.value - a.value;
                });
                
                return mergeGroups;
            }
            
            // ê¸°ì¡´ í•¨ìˆ˜ ìœ ì§€ (í•˜ìœ„ í˜¸í™˜ì„±)
            // ë³‘í•© ê·¸ë£¹ì˜ ê²°ê³¼ ê°’ ê³„ì‚° í•¨ìˆ˜
            function calculateMergeValue(group) {
                // ê·¸ë£¹ì´ ì „ë¶€ ì™€ì¼ë“œì¹´ë“œë¡œë§Œ êµ¬ì„±ëœ ê²½ìš°
                if (group.wildcardCount === group.size) {
                    return WILDCARD_TILE;  // ì™€ì¼ë“œì¹´ë“œ ë°˜í™˜
                }
                
                // ì™€ì¼ë“œì¹´ë“œê°€ í¬í•¨ëœ ê·¸ë£¹ì—ì„œ ì¼ë°˜ íƒ€ì¼ ê°’ì´ 9ë³´ë‹¤ í´ ê²½ìš° ì²˜ë¦¬
                // (ì™€ì¼ë“œì¹´ë“œê°€ 9 ì´í•˜ì˜ íƒ€ì¼ì—ë§Œ ë§¤ì¹­ë˜ë„ë¡ í•˜ëŠ” ë¡œì§ê³¼ ì¼ê´€ì„± ìœ ì§€)
                
                // ì¼ë°˜ íƒ€ì¼ì´ í•˜ë‚˜ ì´ìƒ ìˆëŠ” ê²½ìš°
                // ê·¸ë£¹ì—ì„œ ê°€ì¥ í° ì¼ë°˜ íƒ€ì¼ì˜ ê°’ì„ ì°¾ìŒ
                const regularTileValues = group.tiles
                    .map(p => {
                        const value = typeof p.value !== 'undefined' ? p.value : 
                                     (p.r !== undefined && p.c !== undefined ? grid[p.r][p.c] : null);
                        return value !== WILDCARD_TILE ? value : null;
                    })
                    .filter(v => v !== null);
                
                if (regularTileValues.length === 0) {
                    return WILDCARD_TILE; // ì˜ˆì™¸ ì²˜ë¦¬ - ëª¨ë“  íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš°
                }
                
                // ê°€ì¥ í° ì¼ë°˜ íƒ€ì¼ ê°’ ì°¾ê¸°
                const maxRegularValue = Math.max(...regularTileValues);
                
                // ê·¸ë£¹ í¬ê¸°ì— ë”°ë¥¸ ê²°ê³¼ ê°’ ê³„ì‚°
                // ëª¨ë“  ê·¸ë£¹ì€ 3ê°œì´ë¯€ë¡œ ë¬´ì¡°ê±´ 3ë°° ê°’ ë°˜í™˜
                return maxRegularValue * 3;
            }
            
            // ë³‘í•© ì ìˆ˜ ê³„ì‚° í•¨ìˆ˜
            function calculateScore(group) {
                // ê²°ê³¼ ê°’ ê³„ì‚°
                const resultValue = calculateMergeValue(group);
                
                // ê·¸ë£¹ í¬ê¸°ì— ë”°ë¥¸ ë³´ë„ˆìŠ¤ ì œê±° - ê·¸ë£¹ ëª¨ë‘ 3ê°œë¡œ ì œí•œë˜ì–´ ìˆìŒ
                // ë³´ë„ˆìŠ¤ ì ìˆ˜ ì—†ì´ ê²°ê³¼ ê°’ë§Œ ì ìˆ˜ë¡œ ê³„ì‚°
                return resultValue;
            }
            
            function findAnyGroupGE3() {
                const groups = findMergeGroups(grid, 3);
                if (groups.length === 0) return null;
                
                // ì²« ë²ˆì§¸ ê·¸ë£¹ ë°˜í™˜ (ê°€ì¥ ë†’ì€ ê°’ì„ ê°€ì§„ ê·¸ë£¹)
                const topGroup = groups[0];
                return { 
                    val: topGroup.value, 
                    group: topGroup.tiles 
                };
            }
            function optimizeWildcardUse(group, g = grid) {
                // ê·¸ë£¹ì´ ëª¨ë‘ ì™€ì¼ë“œì¹´ë“œë¡œë§Œ êµ¬ì„±ëœ ê²½ìš°
                if (group.wildcardCount === group.size) {
                    return WILDCARD_TILE;  // ì™€ì¼ë“œì¹´ë“œ ë°˜í™˜
                }
                
                // ì™€ì¼ë“œì¹´ë“œëŠ” 9 ì´í•˜ì˜ íƒ€ì¼ì—ë§Œ ë§¤ì¹­ë˜ë„ë¡ ì œí•œ
                // (í”ŒëŸ¬ë“œí•„ ë¡œì§ê³¼ ì¼ê´€ì„± ìœ ì§€)
                
                // ì£¼ë³€ ë§¥ë½ì„ ë¶„ì„í•˜ì—¬ ì™€ì¼ë“œì¹´ë“œì˜ ìµœì  ê°’ ê²°ì •
                // ì´ í•¨ìˆ˜ëŠ” í˜„ì¬ ê·¸ë£¹ì— ì¼ë°˜ íƒ€ì¼ì´ í•˜ë‚˜ë¼ë„ ìˆë‹¤ê³  ê°€ì •
                
                // í˜„ì¬ ê·¸ë£¹ì˜ ì¼ë°˜ íƒ€ì¼ ê°’ ì°¾ê¸°
                const regularTileValues = group.tiles
                    .map(p => {
                        const value = typeof p.value !== 'undefined' ? p.value : 
                                     (p.r !== undefined && p.c !== undefined ? g[p.r][p.c] : null);
                        return value !== WILDCARD_TILE ? value : null;
                    })
                    .filter(v => v !== null);
                
                if (regularTileValues.length > 0) {
                    // í˜„ì¬ ê·¸ë£¹ ë‚´ì˜ ì¼ë°˜ íƒ€ì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ì™€ì¼ë“œì¹´ë“œ ê°’ ê²°ì •
                    // (ê°€ì¥ í° ê°’ì„ ì„ íƒí•˜ì—¬ ìµœëŒ€ ê²°ê³¼ ê°’ì„ ì–»ìŒ)
                    return Math.max(...regularTileValues);
                } else {
                    // ì˜ˆì™¸ ì²˜ë¦¬ - ëª¨ë“  íƒ€ì¼ì´ ì™€ì¼ë“œì¹´ë“œì¸ ê²½ìš°
                    return WILDCARD_TILE;
                }
            }
            
            /**
             * ë¨¸ì§€ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
             * 
             * @param {Object} [forcePivot=null] - ê°•ì œ í”¼ë´‡ ìœ„ì¹˜ (ì˜µì…˜)
             * @returns {Object} ë¨¸ì§€ ê²°ê³¼ ì •ë³´
             * @returns {boolean} .merged - ë¨¸ì§€ ë°œìƒ ì—¬ë¶€
             * @returns {number} .score - íšë“ ì ìˆ˜
             * @returns {number} .cascadeCount - ì—°ì‡„ ë³‘í•© íšŸìˆ˜
             */
            function checkMergeResult(forcePivot = null) {
                // ê¸°ì¡´ resolveAutoMerges í•¨ìˆ˜ í™œìš©í•˜ì—¬ ë¨¸ì§€ ê²°ê³¼ í™•ì¸
                const result = resolveAutoMerges(forcePivot);
                return result;
            }
            
            /**
             * ë¨¸ì§€ ë°œìƒ í›„ ë³´ìƒ ì¡°ê±´ì„ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
             * 
             * @param {Object} mergeResult - ë¨¸ì§€ ê²°ê³¼ ì •ë³´ ê°ì²´
             * @returns {boolean} ë³´ìƒ ì¡°ê±´ ì¶©ì¡± ì—¬ë¶€
             */
            function shouldShowReward(mergeResult) {
                // ë¨¸ì§€ê°€ ë°œìƒí•˜ì§€ ì•Šì€ ê²½ìš° ë³´ìƒ íŒì—… í‘œì‹œí•˜ì§€ ì•ŠìŒ
                if (!mergeResult || !mergeResult.merged) return false;
                
                // ë³‘í•© ê·¸ë£¹ì— ì•„ì´í…œì„ ê°€ì§„ íƒ€ì¼ì´ ìˆëŠ”ì§€ í™•ì¸
                let hasItemInMerge = false;
                
                // ë³‘í•©ì— ì°¸ì—¬í•œ ëª¨ë“  íƒ€ì¼ì˜ ìœ„ì¹˜ë¥¼ ì €ì¥í•œ ê²ƒì´ mergeResultì— ìˆìœ¼ë©´ ë” ì •í™•í•˜ê²Œ í™•ì¸ ê°€ëŠ¥
                // ì´ í”„ë¡œí† íƒ€ì…ì—ì„œëŠ” ê·¸ëŸ° ì •ë³´ê°€ ì—†ìœ¼ë‹ˆ, í˜„ì¬ ìˆëŠ” ì •ë³´ë§Œìœ¼ë¡œ í™•ì¸
                // í˜„ì¬ ê·¸ë¦¬ë“œì—ì„œ ì•„ì´í…œì„ ê°€ì§„ íƒ€ì¼ì´ ìˆëŠ”ì§€ í™•ì¸
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (hasItem(r, c)) {
                            hasItemInMerge = true;
                            break;
                        }
                    }
                    if (hasItemInMerge) break;
                }
                
                return hasItemInMerge;
            }

            /**
             * ë¨¸ì§€ í›„ ë³´ìƒ íŒì—…ì„ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
             * @returns {boolean} íŒì—… í‘œì‹œ ì„±ê³µ ì—¬ë¶€
             */
            function showRewardPopup() {
                // Get the reward popup element
                const rewardPopup = document.getElementById('rewardPopup');
                if (!rewardPopup) {
                    return false;
                }
                
                // Make sure the reward options are properly initialized
                initRewardHandlers();
                
                // Show the popup
                rewardPopup.classList.add('show');
                
                return true;
            }

            /**
             * ë³´ìƒ íŒì—…ì„ ë‹«ëŠ” í•¨ìˆ˜
             * @param {boolean} wasSelected - ë³´ìƒì´ ì„ íƒë˜ì—ˆëŠ”ì§€ ì—¬ë¶€
             * @returns {boolean} íŒì—… ë‹«ê¸° ì„±ê³µ ì—¬ë¶€
             */
            function closeRewardPopup(wasSelected = true) {
                const rewardPopup = document.getElementById('rewardPopup');
                rewardPopup.classList.remove('show');
                return true;
            }

            /**
             * íŠ¹ì • ê¸°ëŠ¥ì˜ ì‚¬ìš© ê°€ëŠ¥ íšŸìˆ˜ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” í•¨ìˆ˜
             * @param {string} powerupType - ê¸°ëŠ¥ íƒ€ì… ("undo", "blockRemoval", "monsterSpawn", "wildcardSpawn")
             * @param {number} amount - ì¦ê°€ì‹œí‚¬ íšŸìˆ˜ (ê¸°ë³¸ê°’: 1)
             * @returns {boolean} ì¦ê°€ ì²˜ë¦¬ ì„±ê³µ ì—¬ë¶€
             */
            function incrementPowerupUses(powerupType, amount = 1) {
                switch(powerupType) {
                    case "undo":
                        undoUsesLeft += amount;
                        updateUndoButton();
                        break;
                    case "blockRemoval":
                        blockRemovalUsesLeft += amount;
                        updateBlockRemovalButton();
                        break;
                    case "monsterSpawn":
                        monsterSpawnUsesLeft += amount;
                        updateMonsterSpawnButton();
                        break;
                    case "wildcardSpawn":
                        wildcardSpawnUsesLeft += amount;
                        updateWildcardSpawnButton();
                        break;
                    default:
                        return false;
                }
                
                return true;
            }

            /**
             * ë³´ìƒ ì„ íƒ ì‹œ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
             * @param {string} rewardType - ë³´ìƒ íƒ€ì… ("undo", "blockRemoval", "monsterSpawn", "wildcardSpawn")
             * @returns {boolean} ë³´ìƒ ì²˜ë¦¬ ì„±ê³µ ì—¬ë¶€
             */
            function selectReward(rewardType) {
                if (!rewardType) {
                    info('ë³´ìƒ ì„ íƒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'err');
                    return false;
                }
                
                // ë³´ìƒ ì´ë¦„ ë§¤í•‘
                const rewardNames = {
                    "undo": "ë˜ëŒë¦¬ê¸°",
                    "blockRemoval": "ë¸”ë¡ ì œê±°",
                    "monsterSpawn": "ëª¬ìŠ¤í„° ì†Œí™˜",
                    "wildcardSpawn": "ì¡°ì»¤ ì†Œí™˜"
                };
                
                // ëª…ì‹œì ìœ¼ë¡œ ê° ë³´ìƒ íƒ€ì… ì²˜ë¦¬
                let success = false;
                switch(rewardType) {
                    case "undo":
                        undoUsesLeft += 1;
                        updateUndoButton();
                        success = true;
                        break;
                    case "blockRemoval":
                        blockRemovalUsesLeft += 1;
                        updateBlockRemovalButton();
                        success = true;
                        break;
                    case "monsterSpawn":
                        monsterSpawnUsesLeft += 1;
                        updateMonsterSpawnButton();
                        success = true;
                        break;
                    case "wildcardSpawn":
                        wildcardSpawnUsesLeft += 1;
                        updateWildcardSpawnButton();
                        success = true;
                        break;
                    default:
                        success = false;
                }
                
                // ëª¨ë“  ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸ (í•œë²ˆì— ëª¨ë“  ë²„íŠ¼ ê°±ì‹ )
                updateAllButtons();
                
                // íŒì—… ë‹«ê¸° (ì„±ê³µ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ë‹«ìŒ)
                closeRewardPopup(success);
                
                // ì„±ê³µí•œ ê²½ìš°ì—ë§Œ ì•ˆë‚´ ë©”ì‹œì§€ í‘œì‹œ
                if (success) {
                    info(`${rewardNames[rewardType]} ê¸°ëŠ¥ì´ 1íšŒ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`);
                } else {
                    info('ë³´ìƒ ì„ íƒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'err');
                }
                
                return success;
            }
            
            /**
             * ë³´ìƒ ì˜µì…˜ í´ë¦­ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì´ˆê¸°í™”
             */
            function initRewardHandlers() {
                const rewardOptions = document.querySelectorAll('.reward-option');
                
                rewardOptions.forEach((option) => {
                    // Remove any existing click listeners to avoid duplicates
                    const newOption = option.cloneNode(true);
                    option.parentNode.replaceChild(newOption, option);
                    
                    // Add the new click listener
                    newOption.addEventListener('click', function(event) {
                        // Stop event propagation to prevent any parent handlers from triggering
                        event.stopPropagation();
                        
                        const rewardType = this.getAttribute('data-type');
                        
                        // Call selectReward with a slight delay to ensure the event completes
                        setTimeout(() => {
                            selectReward(rewardType);
                        }, 10);
                    });
                });
            }

            function resolveAutoMerges(forcePivot = null) {
                let merged = false;
                let totalScore = 0;
                let cascadeCount = 0;
                
                while (true) {
                    // ë³‘í•© ê°€ëŠ¥í•œ ëª¨ë“  ê·¸ë£¹ ì°¾ê¸°
                    const mergeGroups = findMergeGroups(grid, 3);
                    if (mergeGroups.length === 0) break;
                    
                    // í˜„ì¬ ë‹¨ê³„ì˜ ë³‘í•©ì„ ì²˜ë¦¬í–ˆìŒì„ í‘œì‹œ
                    cascadeCount++;
                    
                    // ê°•ì œ í”¼ë´‡ì´ ì§€ì •ëœ ê²½ìš° í•´ë‹¹ ê·¸ë£¹ ì°¾ê¸°
                    let selectedGroup = mergeGroups[0];  // ê¸°ë³¸ê°’ì€ ì²« ë²ˆì§¸ ê·¸ë£¹
                    
                    if (forcePivot) {
                        // ê°•ì œ í”¼ë´‡ì´ ìˆëŠ” ê²½ìš°, í•´ë‹¹ í”¼ë´‡ì„ í¬í•¨í•˜ëŠ” ê·¸ë£¹ ì°¾ê¸°
                        const forcedGroup = mergeGroups.find(g => 
                            g.tiles.some(t => t.r === forcePivot.r && t.c === forcePivot.c));
                        
                        if (forcedGroup) {
                            selectedGroup = forcedGroup;
                        }
                    }
                    
                    // ì„ íƒëœ ê·¸ë£¹ì˜ ì •ë³´ ì¶”ì¶œ
                    let { tiles, value, wildcardCount, size } = selectedGroup;
                    
                    // pivotì„ ê²°ì •: forcePivotì´ ìˆê³  ê·¸ë£¹ì— í¬í•¨ëœ ê²½ìš° forcePivotì„ pivotìœ¼ë¡œ ì‚¬ìš©
                    let pivot = selectedGroup.pivot;
                    if (forcePivot && tiles.some(t => t.r === forcePivot.r && t.c === forcePivot.c)) {
                        pivot = forcePivot;
                    }
                    
                    // í•„ìš”ì‹œ ì™€ì¼ë“œì¹´ë“œ ìµœì í™” ìˆ˜í–‰
                    const optimizedValue = (wildcardCount > 0) ? 
                        optimizeWildcardUse(selectedGroup) : value;
                    
                    // ë³‘í•© ê²°ê³¼ ê°’ ê³„ì‚°
                    const resultValue = calculateMergeValue(selectedGroup);
                    
                    // ë³‘í•© ì ìˆ˜ ê³„ì‚°
                    const groupScore = calculateScore(selectedGroup);
                    totalScore += groupScore;
                    
                    // ê·¸ë£¹ í¬ê¸°ì— ë”°ë¥¸ ì ìˆ˜ í‘œì‹œ ì• ë‹ˆë©”ì´ì…˜
                    const scoreElem = document.createElement('div');
                    scoreElem.className = 'score-popup';
                    
                    try {
                        // ë³´ë“œ ìš”ì†Œì™€ íƒ€ì¼ ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                        const pivotIdx = pivot.r * COLS + pivot.c;
                        const pivotCell = board.children[pivotIdx];
                        
                        if (board && pivotCell) {
                            const boardRect = board.getBoundingClientRect();
                            const cellRect = pivotCell.getBoundingClientRect();
                            
                            // ì ìˆ˜ íŒì—…ì˜ ìœ„ì¹˜ ì„¤ì •
                            scoreElem.style.left = (cellRect.left + cellRect.width / 2 - boardRect.left) + 'px';
                            scoreElem.style.top = (cellRect.top - boardRect.top - 30) + 'px';
                        } else {
                            // ìš”ì†Œê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ìœ„ì¹˜ë¥¼ ì„¤ì •
                            scoreElem.style.left = '50%';
                            scoreElem.style.top = '50%';
                            scoreElem.style.transform = 'translate(-50%, -50%)';
                        }
                    } catch (e) {
                        // getBoundingClientRect ì˜ˆì™¸ê°€ ë°œìƒí•œ ê²½ìš° ê¸°ë³¸ ìœ„ì¹˜ë¥¼ ì„¤ì •
                        console.warn('Failed to position score popup:', e);
                        scoreElem.style.left = '50%';
                        scoreElem.style.top = '50%';
                        scoreElem.style.transform = 'translate(-50%, -50%)';
                    }
                    
                    // ê·¸ë£¹ í¬ê¸° ëª¨ë‘ 3ê°œë¡œ ì œí•œë˜ì–´ ë³´ë„ˆìŠ¤ ì ìˆ˜ í‘œì‹œ ì—†ìŒ
                    scoreElem.textContent = `+${groupScore}`;
                    
                    board.appendChild(scoreElem);
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ìš”ì†Œ ì œê±°
                    setTimeout(() => scoreElem.remove(), 900);
                    
                    // í”¼ë´‡ íƒ€ì¼ì´ ì•„ë‹Œ ëª¨ë“  íƒ€ì¼ì„ ì œê±°í•˜ê³  í”¼ë´‡ì— ê²°ê³¼ ê°’ ì„¤ì •
                    const absorbTiles = tiles.filter(t => t.r !== pivot.r || t.c !== pivot.c);
                    
                    // ë³‘í•©ëœ íƒ€ì¼ì— ì•„ì´í…œì´ ìˆëŠ”ì§€ í™•ì¸ ë° ì²˜ë¦¬
                    // ë³‘í•©ëœ ê·¸ë£¹ì˜ ì–´ëŠ íƒ€ì¼ì´ë¼ë„ ì•„ì´í…œì„ ê°–ê³  ìˆìœ¼ë©´ í”¼ë´‡ì—ë„ ì•„ì´í…œ í‘œì‹œ
                    let hasAnyItemInMerge = false;
                    
                    // ë³‘í•©ë˜ëŠ” ëª¨ë“  íƒ€ì¼ í™•ì¸ (í”¼ë´‡ í¬í•¨)
                    for (const tile of tiles) {
                        if (hasItem(tile.r, tile.c)) {
                            hasAnyItemInMerge = true;
                            break;
                        }
                    }
                    
                    // ê·¸ë¦¬ë“œ ì—…ë°ì´íŠ¸
                    for (const tile of absorbTiles) {
                        // íƒ€ì¼ ì œê±° ì‹œ ì•„ì´í…œ ì •ë³´ë„ ì œê±°
                        grid[tile.r][tile.c] = 0;
                        setItem(tile.r, tile.c, false);
                        drawCell(tile.r, tile.c);
                    }
                    
                    // ê²°ê³¼ ê°’ì„ í”¼ë´‡ ìœ„ì¹˜ì— ì„¤ì •
                    grid[pivot.r][pivot.c] = resultValue;
                    
                    // ì•„ì´í…œì´ í•˜ë‚˜ë¼ë„ ìˆì—ˆìœ¼ë©´ ê²°ê³¼ íƒ€ì¼ì—ë„ ì•„ì´í…œ í‘œì‹œ
                    setItem(pivot.r, pivot.c, hasAnyItemInMerge);
                    
                    drawCell(pivot.r, pivot.c);
                    
                    // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ - ìƒˆë¡œìš´ pivot ìœ„ì¹˜ì— ë§ê²Œ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
                    // ë³´ë“œì˜ ìì‹ ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                    const pivotIdx = pivot.r * COLS + pivot.c;
                    const pivotChild = board.children[pivotIdx];
                    let tCell = null;
                    
                    // ì•ˆì „í•˜ê²Œ íƒ€ì¼ ìš”ì†Œ ê°€ì ¸ì˜¤ê¸°
                    if (pivotChild) {
                        tCell = pivotChild.querySelector('.tile');
                    }
                    
                    if (tCell) {
                        // íƒ€ì¼ ì¤‘ì•™ ì¢Œí‘œ êµ¬í•˜ê¸°
                        let cellCenterX = 0;
                        let cellCenterY = 0;
                        
                        try {
                            const cellRect = tCell.getBoundingClientRect();
                            cellCenterX = cellRect.left + cellRect.width / 2;
                            cellCenterY = cellRect.top + cellRect.height / 2;
                        } catch (e) {
                            // getBoundingClientRectê°€ ì‹¤íŒ¨í•˜ëŠ” ê²½ìš° ê¸°ë³¸ê°’ ì‚¬ìš©
                            console.warn('Failed to get tile position:', e);
                        }
                        
                        // ê·¸ë£¹ í¬ê¸°ê°€ ëª¨ë‘ 3ê°œë¡œ ì œí•œë˜ì–´ í•­ìƒ ê¸°ë³¸ ë³‘í•© íš¨ê³¼ë§Œ ì‚¬ìš©
                        tCell.classList.add('merge');
                        // ë¨¸ì§€ ì™„ë£Œí›„ ì¶”ê°€ íš¨ê³¼ (after-merge íš¨ê³¼ ì¶”ê°€)
                        setTimeout(() => {
                            tCell.classList.remove('merge');
                            tCell.classList.add('after-merge');
                            setTimeout(() => {
                                tCell.classList.remove('after-merge');
                            }, 800);
                        }, 600); // ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ ì¦ê°€ (0.5ì´ˆ + ì•½ê°„ì˜ ì—¬ìœ )
                        
                        // ê¸°ë³¸ íŒŒí‹°í´ íš¨ê³¼
                        createParticles(cellCenterX, cellCenterY, 8, 1.0);
                    }
                    
                    // ğŸµ ë³‘í•© íš¨ê³¼ìŒ (ê·¸ë£¹ í¬ê¸° 3ê°œë¡œ ëª¨ë‘ ë™ì¼ - ê¸°ë³¸ íš¨ê³¼ìŒë§Œ ì‚¬ìš©)
                    if (sounds.blocks[value * 3]) {
                        sounds.blocks[value * 3].currentTime = 0;
                        playSoundSafely(sounds.blocks[value * 3]);
                    }
                    
                    merged = true;
                    forcePivot = null;  // í˜„ì¬ ë³‘í•© í›„ì—ëŠ” forcePivot ì¬ì„¤ì •
                }
                
                // ìë™ ë³‘í•© ë° ëª¨ë“  ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì—ˆìŒ
                // saveSnapshot í˜¸ì¶œì€ ëª¨ë“  ì²˜ë¦¬ê°€ ì™„ë£Œëœ í›„ í•œ ë²ˆë§Œ ìˆ˜í–‰ë¨
                
                // ë³‘í•© ê²°ê³¼ ì •ë³´ ë°˜í™˜
                return {
                    merged,
                    score: totalScore,
                    cascadeCount
                };
                
                // ë³‘í•© ê²°ê³¼ ë°˜í™˜
                return {
                    merged,
                    score: totalScore,
                    cascadeCount
                };
            }


            /* ====== ê²Œì„ì˜¤ë²„ ====== */
            // ì´ë™ ê²€ì¦ í•¨ìˆ˜ - í–¥ìƒëœ ë³‘í•© ë¡œì§ ì§€ì›
            function validateMergeMove(fromPos, toPos, value, g = grid) {
                // ê¸°ë³¸ ê²€ì¦ - ê²½ë¡œ ì¡´ì¬ ì—¬ë¶€
                const path = findPathViaEmpties(fromPos, toPos, g);
                if (!path) {
                    return {
                        valid: false,
                        groupSize: 0,
                        reasons: ["ê²½ë¡œê°€ ë§‰í˜€ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."]
                    };
                }
                
                // ì´ë™ í›„ ê·¸ë£¹ í¬ê¸° ê³„ì‚° - í˜„ì¬ ê·¸ë£¹ì˜ ì •í™•í•œ í¬ê¸° íŒŒì•…
                const currentGroup = floodSame(fromPos.r, fromPos.c, value, g, Infinity);
                const groupSizeAfterMove = groupSizeIfMoved(fromPos, toPos, value);
                
                // ì´ë™ í›„ ìœ íš¨ì„± ê²€ì‚¬
                const reasons = [];
                
                // ê·¸ë£¹ í˜•ì„± í™•ì¸
                if (groupSizeAfterMove < 2) {
                    reasons.push("ì´ë™í•´ë„ ê·¸ë£¹ì´ í˜•ì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
                }
                
                // í˜„ì¬ 2ê°œ ê·¸ë£¹ì„ ë¶„ë¦¬í•˜ëŠ” ê²½ìš°, 3ë§¤ì¹­ì´ ë˜ì–´ì•¼ í•¨
                // ì™€ì¼ë“œì¹´ë“œ ì˜ˆì™¸ ì²˜ë¦¬
                if (currentGroup.length === 2 && groupSizeAfterMove < 3) {
                    // ì™€ì¼ë“œì¹´ë“œëŠ” 2ê°œ ì´ìƒì˜ ê·¸ë£¹ì„ í˜•ì„±í•  ìˆ˜ ìˆìœ¼ë©´ 2ê·¸ë£¹ì—ì„œë„ ì´ë™ ê°€ëŠ¥
                    if (value === WILDCARD_TILE && groupSizeAfterMove >= 2) {
                        // ì™€ì¼ë“œì¹´ë“œ ì˜ˆì™¸ ì ìš©: ê²€ì¦ í†µê³¼
                    } else {
                        reasons.push("3ë§¤ì¹­ ëª©ì ì´ ì•„ë‹ˆë©´ ë‘ê°œë¥¼ ë–¼ì–´ ë†“ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    }
                }
                
                return {
                    valid: reasons.length === 0,
                    groupSize: groupSizeAfterMove,
                    reasons
                };
            }
            
            function legalMoveExistsForTile(r, c) {
                const v = grid[r][c]; 
                const currentGroup = floodSame(r, c, v);
                
                for (let rr = 0; rr < ROWS; rr++)for (let cc = 0; cc < COLS; cc++) {
                    if (!isEmpty(rr, cc)) continue;
                    
                    const from = { r, c };
                    const to = { r: rr, c: cc };
                    
                    // validateMergeMove í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ íš¨ì„± ê²€ì‚¬
                    const validationResult = validateMergeMove(from, to, v);
                    if (validationResult.valid) {
                        return true;
                    }
                }
                return false;
            }
            function hasAnyMoves() {
                for (let r = 0; r < ROWS; r++)for (let c = 0; c < COLS; c++)
                    // ì™€ì¼ë“œì¹´ë“œë„ ì¼ë°˜ íƒ€ì¼ì²˜ëŸ¼ ì´ë™ ê°€ëŠ¥
                    if ((grid[r][c] > 0 || grid[r][c] === WILDCARD_TILE) && legalMoveExistsForTile(r, c)) return true;
                return false;
            }
            function checkGameOverSoon() {
                setTimeout(() => {
                    if (!gameOverShown && !hasAnyMoves()) {
                        gameOverShown = true;
                        const total = grid.flat().filter(v => v > 0).reduce((a, b) => a + b, 0);
                        showResult(total);
                    }
                }, 30);
            }

            /* ====== íˆìŠ¤í† ë¦¬ ====== */
            function saveSnapshot() {
                history.push({ 
                    grid: cloneGrid(grid), 
                    tileItems: {...tileItems}, // ì•„ì´í…œ ì •ë³´ ë³µì‚¬
                    turn, 
                    untilSpawn, 
                    blockSpawnTurn 
                });
                if (history.length > 50) history.shift();
                
                // ë˜ëŒë¦¬ê¸° ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
                updateUndoButton();
            }
            
            function updateUndoButton() {
                const btnUndo = document.getElementById('btnUndo');
                if (!btnUndo) return;
                
                if (history.length === 0) {
                    btnUndo.disabled = true;
                    btnUndo.style.opacity = "0.5";
                } else {
                    btnUndo.disabled = false;
                    btnUndo.style.opacity = "1";
                }
            }
            
            function undoMove() {
                // ë˜ëŒë¦´ ì´ë™ì´ ì—†ìœ¼ë©´ ë©”ì‹œì§€ í‘œì‹œ
                if (history.length === 0) {
                    info("ë˜ëŒë¦´ ì´ë™ì´ ì—†ìŠµë‹ˆë‹¤.", "warn");
                    return false;
                }
                
                // ë‚¨ì€ ë˜ëŒë¦¬ê¸° íšŸìˆ˜ í™•ì¸
                if (undoUsesLeft <= 0) {
                    info("ë˜ëŒë¦¬ê¸° ê¸°ëŠ¥ì„ ëª¨ë‘ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.", "err");
                    return false;
                }
                
                // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ì¤‘ì—ëŠ” ë˜ëŒë¦¬ê¸° ë¶ˆê°€
                if (isAnimating) {
                    info("ì• ë‹ˆë©”ì´ì…˜ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.", "warn");
                    return false;
                }
                
                // ê²Œì„ ì˜¤ë²„ í™”ë©´ì´ í‘œì‹œëœ ìƒíƒœì—ì„œëŠ” ë˜ëŒë¦¬ê¸° ë¶ˆê°€
                if (gameOverShown) {
                    info("ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œëŠ” ë˜ëŒë¦¬ê¸°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", "warn");
                    return false;
                }
                
                // ì´ì „ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
                const prevState = history.pop();
                
                // ê²Œì„ ìƒíƒœ ë³µì›
                grid = prevState.grid;
                turn = prevState.turn;
                untilSpawn = prevState.untilSpawn;
                blockSpawnTurn = prevState.blockSpawnTurn;
                
                // ì•„ì´í…œ ì •ë³´ ë³µì›
                if (prevState.tileItems) {
                    tileItems = {...prevState.tileItems};
                } else {
                    // ì´ì „ ë²„ì „ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ ëª¨ë“  íƒ€ì¼ì— ì•„ì´í…œ ë¶€ì—¬
                    clearItems();
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (grid[r][c] > 0 || grid[r][c] === WILDCARD_TILE) {
                                setItem(r, c, true);
                            }
                        }
                    }
                }
                
                // UI ì—…ë°ì´íŠ¸
                renderAll();
                selected = null;
                highlightSelection();
                clearPossibleMoves();
                
                // ë˜ëŒë¦¬ê¸° ì‹œê°ì  íš¨ê³¼ - ë³´ë“œ ì „ì²´ ê°•ì¡° íš¨ê³¼
                board.classList.add('undo-flash');
                setTimeout(() => {
                    board.classList.remove('undo-flash');
                }, 300);
                
                // ë˜ëŒë¦¬ê¸° íš¨ê³¼ìŒ
                sounds.click.currentTime = 0;
                playSoundSafely(sounds.click);
                
                // ì‚¬ìš© íšŸìˆ˜ ì°¨ê°
                undoUsesLeft--;
                
                // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
                info("ì´ì „ ì´ë™ìœ¼ë¡œ ë˜ëŒì•„ê°”ìŠµë‹ˆë‹¤.", "");
                
                // ë˜ëŒë¦¬ê¸° ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
                updateUndoButton();
                
                return true;
            }

            /* ====== ê²°ê³¼ ====== */
            async function showResult(total) {
                popupTitle.textContent = "ê²Œì„ ì˜¤ë²„";
                finalScore.textContent = `${playerId}ì˜ ìµœì¢… ì ìˆ˜: ${total}`;
                noMovesMsg.style.display = "block";
                lastGameState = cloneGrid(grid);

                if (total > bestScore) {
                    bestScore = total;
                    bestGameState = cloneGrid(grid);
                    localStorage.setItem("mergeBestScore", bestScore);
                    localStorage.setItem("mergeBestState", JSON.stringify(bestGameState));
                }

                rankingsEl.innerHTML = "<div style='padding:10px'>ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ì¤‘...</div>";
                popup.classList.add('show');

                // ğŸµ ê²Œì„ì˜¤ë²„ìŒ
                sounds.gameover.currentTime = 0;
                playSoundSafely(sounds.gameover);

                try {
                    await fetch(GAS_URL, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ secret: "TEST2", name: playerId, score: total, state: grid }),
                        mode: "no-cors"
                    });
                    console.log("âœ… ì €ì¥ ìš”ì²­ ë³´ëƒ„");
                } catch (e) { console.error("âŒ POST ì˜¤ë¥˜:", e); }

                loadRanking();
            }
            /* ====== ë­í‚¹ ====== */
            async function loadRanking() {
                try {
                    const res = await fetch(`${GAS_URL}?mode=ranking`, { cache: "no-cache" });
                    let data = [];
                    try { data = await res.json(); } catch (e) { console.error("âŒ JSON íŒŒì‹± ì‹¤íŒ¨:", e); }
                    renderRanking(Array.isArray(data) ? data.slice(0, 100) : []);
                } catch (e) {
                    console.error("âŒ ë­í‚¹ fetch ì‹¤íŒ¨:", e);
                    renderRanking([]);
                }
            }
            function renderRanking(rows) {
                rankingsEl.innerHTML = "";
                if (!rows || rows.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.padding = '10px';
                    empty.textContent = 'ë­í‚¹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.';
                    rankingsEl.appendChild(empty);
                    return;
                }
                rows.forEach((row, i) => {
                    const item = document.createElement('div');
                    item.className = 'rank-item' + (i === 0 ? ' top1' : i === 1 ? ' top2' : i === 2 ? ' top3' : '');
                    const left = document.createElement('div'); left.className = 'left';
                    const crown = document.createElement('span'); crown.className = 'crown'; crown.textContent = (i < 3 ? 'ğŸ‘‘' : '');
                    left.appendChild(crown);
                    const name = document.createElement('span'); name.textContent = `${i + 1}. ${row.name}`; left.appendChild(name);

                    const right = document.createElement('div'); right.className = 'right';
                    if (i < 3) {
                        const btn = document.createElement('button'); btn.textContent = "ë³´ê¸°"; btn.className = "btn";
                        btn.addEventListener('click', async () => {
                            try {
                                if (row.state) { renderMiniPopup(JSON.parse(row.state), row.name, row.score); }
                                else {
                                    const res = await fetch(`${GAS_URL}?mode=last&name=${encodeURIComponent(row.name)}`);
                                    const data = await res.json();
                                    if (data.state) renderMiniPopup(JSON.parse(data.state), data.name, data.score);
                                    else alert("ì €ì¥ëœ ì „ì ì´ ì—†ìŠµë‹ˆë‹¤.");
                                }
                            } catch (e) { console.error("âŒ last fetch ì˜¤ë¥˜:", e); alert("ì „ì ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); }
                        });
                        right.appendChild(btn);
                    }
                    const score = document.createElement('span'); score.className = 'score'; score.textContent = `${row.score}`;
                    right.appendChild(score);
                    item.appendChild(left); item.appendChild(right); rankingsEl.appendChild(item);
                });
            }

            /* ====== ë¯¸ë‹ˆíŒì—… ====== */
            function renderMiniPopup(state, id, score) {
                let mini = document.getElementById('miniPopup');
                if (!mini) {
                    mini = document.createElement('div'); mini.id = 'miniPopup';
                    mini.style.position = 'fixed'; mini.style.inset = '0'; mini.style.background = 'rgba(0,0,0,0.6)';
                    mini.style.display = 'flex'; mini.style.alignItems = 'center'; mini.style.justifyContent = 'center';
                    mini.style.zIndex = '2000'; document.body.appendChild(mini);
                }
                mini.innerHTML = '';
                const box = document.createElement('div');
                box.style.background = '#161c29'; box.style.padding = '16px'; box.style.borderRadius = '12px';
                box.style.textAlign = 'center'; box.style.boxShadow = '0 6px 20px rgba(0,0,0,0.6)';
                const title = document.createElement('h3'); title.textContent = `${id} ìµœì¢… ë³´ë“œ (ì ìˆ˜ ${score})`; box.appendChild(title);

                const wrap = document.createElement('div');
                wrap.style.display = 'grid';
                wrap.style.gridTemplateColumns = `repeat(${COLS},1fr)`;
                wrap.style.gridTemplateRows = `repeat(${ROWS},1fr)`;
                wrap.style.gap = '4px'; wrap.style.width = '90%'; wrap.style.maxWidth = '420px';
                wrap.style.aspectRatio = `${COLS}/${ROWS}`; wrap.style.margin = '12px auto';
                for (let r = 0; r < ROWS; r++)for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = '100%'; cell.style.aspectRatio = '1/1'; cell.style.border = '1px solid #222'; cell.style.background = '#111';
                    const v = state[r][c];
                    if ((v > 0 || v === WILDCARD_TILE) && TILE_IMAGES[v]) {
                        cell.style.backgroundImage = `url(${TILE_IMAGES[v]})`; 
                        cell.style.backgroundSize = "contain"; 
                        cell.style.backgroundRepeat = "no-repeat"; 
                        cell.style.backgroundPosition = "center";
                        // ë­í‚¹ ë³´ë“œì—ì„œ ì™€ì¼ë“œì¹´ë“œ íƒ€ì¼ì— íš¨ê³¼ ì¶”ê°€
                        if (v === WILDCARD_TILE) {
                            cell.style.boxShadow = "0 0 10px gold, 0 0 20px rgba(255, 215, 0, 0.7)";
                        }
                    }
                    else if (v === -1) { cell.style.backgroundImage = "url('images/blocked.png')"; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    else { cell.style.backgroundImage = "url('images/empty.png')"; cell.style.backgroundSize = "contain"; cell.style.backgroundRepeat = "no-repeat"; cell.style.backgroundPosition = "center"; }
                    wrap.appendChild(cell);
                }
                box.appendChild(wrap);
                const close = document.createElement('button'); close.textContent = 'ë‹«ê¸°'; close.className = 'btn'; close.style.marginTop = '10px'; close.onclick = () => mini.remove(); box.appendChild(close);
                mini.appendChild(box);
            }

            /* ====== ê¸°íƒ€ ì´ë²¤íŠ¸ ====== */
            document.addEventListener('click', (e) => {
                if (!toast.classList.contains('show')) return;
                if (e.target.closest('#toast')) return;
                if (toastTimer) clearTimeout(toastTimer);
                setTimeout(() => { toast.classList.remove('show'); toastTimer = null; }, 50);
            }, true);

            /* ====== ì‹œì‘ ====== */
            preloadImages(IMAGE_URLS).then(() => {
                console.log("âœ… ëª¨ë“  ì´ë¯¸ì§€ í”„ë¦¬ë¡œë“œ ì™„ë£Œ");
                init();

               
            });
        })();
        // ğŸµ ì²« í„°ì¹˜/í´ë¦­ ì‹œ BGM ì‹œì‘
        function startBgm() {
            if (sounds.bgm && sounds.bgm.paused) {
                try {
                    // ì˜¤ë””ì˜¤ ì¬ìƒ ì‹œë„
                    const playPromise = sounds.bgm.play();
                    
                    // í”„ë¡œë¯¸ìŠ¤ ìˆì„ ê²½ìš° ì²˜ë¦¬
                    if (playPromise !== undefined) {
                        playPromise
                            .then(() => {
                                console.log("ğŸ¶ BGM ì‹œì‘ë¨");
                            })
                            .catch(err => {
                                console.log("ğŸ”‡ BGM ì‹œì‘ ì‹¤íŒ¨:", err);
                            });
                    } else {
                        console.log("ğŸ¶ BGM ì¬ìƒ ì‹œë„");
                    }
                } catch (e) {
                    console.warn('BGM ì¬ìƒ ì˜¤ë¥˜:', e);
                }
            }
        }

        document.addEventListener("touchstart", startBgm, { once: true });
        document.addEventListener("click", startBgm, { once: true });

        // ğŸ”¥ ì•±/íƒ­ ì „í™˜ ì‹œ BGM ì œì–´
    function pauseBgm() {
        if (window.sounds && window.sounds.bgm && !window.sounds.bgm.paused) {
            window.sounds.bgm.pause();
        }
    }
    function resumeBgm() {
        if (window.sounds && window.sounds.bgm) {
            window.playSoundSafely(window.sounds.bgm);
        }
    }


        document.addEventListener("visibilitychange", () => {
            if (document.hidden) pauseBgm();
            else resumeBgm();
        });

        window.addEventListener("pagehide", pauseBgm);
        window.addEventListener("pageshow", resumeBgm);

        window.addEventListener("blur", pauseBgm);
        window.addEventListener("focus", resumeBgm);

    </script>
</body>

</html>











